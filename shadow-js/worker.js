importScripts("shared.js");
(function(){
'use strict';var cx=function(a){return function(b){return function(){function c(g,k){k=a.g?a.g(k):a.call(null,k);return null==k?g:b.h?b.h(g,k):b.call(null,g,k)}function d(g){return b.g?b.g(g):b.call(null,g)}function e(){return b.m?b.m():b.call(null)}var f=null;f=function(g,k){switch(arguments.length){case 0:return e.call(this);case 1:return d.call(this,g);case 2:return c.call(this,g,k)}throw Error("Invalid arity: "+arguments.length);};f.m=e;f.g=d;f.h=c;return f}()}},dx=function(a){var b=new $APP.na;
for(a=$APP.A(a);;)if(null!=a)b=b.append($APP.t.g($APP.D(a))),a=$APP.F(a);else return b.toString()},ex=function(a,b){return $APP.Lb($APP.Ia(function(c,d){return $APP.r(a.g?a.g(d):a.call(null,d))?$APP.Kb(c,d):c},$APP.Jb($APP.Oe),b))},fx=function(a){return 0<a?new $APP.Ie(null,a,"?",null):$APP.mc},gx=function(a,b){return new $APP.Nd(null,function(){var c=$APP.A(b);if(c){var d=$APP.D(c);d=a.g?a.g(d):a.call(null,d);c=$APP.r(d)?$APP.Hd($APP.D(c),gx(a,$APP.nc(c))):null}else c=null;return c},null,null)},
hx=function(a){var b=$APP.we($APP.Vc);return new $APP.S(null,2,5,$APP.U,[gx(b,a),$APP.He(b,a)],null)},ix=function(a,b){return new $APP.Nd(null,function(){var c=$APP.A(b);if(c){var d=$APP.D(c),e=a.g?a.g(d):a.call(null,d),f=$APP.Hd(d,gx(function(g){return $APP.H.h(e,a.g?a.g(g):a.call(null,g))},$APP.F(c)));return $APP.Hd(f,ix(a,new $APP.Nd(null,function(){return $APP.De($APP.G(f),c)},null,null)))}return null},null,null)},jx=function(a,b){return function f(d,e){return new $APP.Nd(null,function(){var g=
$APP.A(e);if(g){if($APP.Yc(g)){for(var k=$APP.Qb(g),l=$APP.G(k),m=$APP.Qd(l),n=0;;)if(n<l)$APP.Ud(m,function(){var u=d+n,v=$APP.Mc(k,n);return a.h?a.h(u,v):a.call(null,u,v)}()),n+=1;else break;return $APP.Td($APP.Vd(m),f(d+l,$APP.Rb(g)))}return $APP.Hd(function(){var u=$APP.D(g);return a.h?a.h(d,u):a.call(null,d,u)}(),f(d+1,$APP.nc(g)))}return null},null,null)}(0,b)},kx=function(a,b,c){return new $APP.Nd(null,function(){var d=$APP.A(c);return d?$APP.Hd($APP.pi.h(a,d),kx(a,b,$APP.De(b,d))):null},null,
null)},lx=function(a,b,c){return new $APP.Nd(null,function(){var d=$APP.A(c);if(d){var e=$APP.pi.h(a,d);return a===$APP.G(e)?$APP.Hd(e,lx(a,b,$APP.De(b,d))):null}return null},null,null)},ox=function(a){var b=$APP.O.h($APP.Qc(a),$APP.N(mx,new $APP.q(null,1,[nx,!0],null)));if(b)a=b.g?b.g(a):b.call(null,a);else if(null!=a&&null!=a.Xc)a=a.Xc(a);else if(b=ox[$APP.p(null==a?null:a)],null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=ox._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.Fa("InlineValue.sqlize",
a);return a},qx=function(a,b,c){var d=$APP.Ag(a);a=$APP.fd(d,b)?ex(function(e){return $APP.pe(e,b)},a):a;if($APP.r(c)){if(!$APP.fd(d,c))throw $APP.Th(["Unrecognized clause: ",$APP.t.g(c)].join(""),new $APP.q(null,1,[px,a],null));return $APP.Ia(function(e,f){return $APP.H.h(f,c)?$APP.Ed.l(e,b,$APP.K([f])):$APP.Ed.h(e,f)},$APP.Oe,a)}return $APP.Ed.h(a,b)},rx=function(a,b,c){return[$APP.t.g(a),$APP.Xh(b,$APP.t.g(c),[$APP.t.g(c),$APP.t.g(c)].join("")),$APP.t.g(c)].join("")},tx=function(a){return $APP.fd(sx,
a)||$APP.fd(sx,a instanceof $APP.P?$APP.ch.g($APP.Cg(a)):$APP.Wg.g($APP.Cg(a)))},vx=function(a){try{return $APP.Xh($APP.Cg(a),"-","_")}catch(c){var b=c;throw $APP.Th(["expected symbol, found: ",$APP.t.g($APP.Ea(a))].join(""),new $APP.q(null,2,[$APP.Cj,a,ux,$APP.t.g(b)],null));}},xx=function(a){a=$APP.Xh($APP.Cg(a),"?","??");return $APP.H.h("'",$APP.D(a))?wx($APP.Wg.g(a.substring(1,a.length))):$APP.Xh(a,/(\w)-(?=\w)/,"$1 ").toUpperCase()},yx=function(a){if(a instanceof $APP.y){var b=$APP.Kd(a);return $APP.r(b)?
$APP.Wg.h(b,$APP.Cg(a)):$APP.Wg.g($APP.Cg(a))}return a},Bx=function(a){if($APP.fd(zx,a))return $APP.O.h(zx,a);throw $APP.Th(["missing parameter value for ",$APP.t.g(a)].join(""),new $APP.q(null,1,[Ax,$APP.qg(zx)],null));},Dx=function(a){return $APP.N($APP.xe(a),new $APP.q(null,1,[Cx,function(b){return Bx(b.m?b.m():b.call(null))}],null))},Fx=function(a,b){var c=$APP.M(b,0,null);b=function(){var e=$APP.t.g(a);return a instanceof $APP.P?e.substring(1):e}();if($APP.H.h("%",$APP.D(b))){b=$APP.$h(b.substring(1),
/\./);var d=$APP.A(b);b=$APP.D(d);d=$APP.F(d);d=$APP.Q.h(function(e){return wx.l($APP.Wg.g(e),$APP.K([c]))},d);return new $APP.S(null,1,5,$APP.U,[[$APP.Xh(b,"-","_").toUpperCase(),"(",$APP.Yh(", ",d),")"].join("")],null)}return $APP.H.h("?",$APP.D(b))?(b=$APP.Wg.g(b.substring(1)),$APP.r(Ex)?new $APP.S(null,1,5,$APP.U,[ox(Bx(b))],null):new $APP.S(null,2,5,$APP.U,["?",Dx(b)],null)):new $APP.S(null,1,5,$APP.U,[wx.l(a,$APP.K([c]))],null)},Jx=function(a){if($APP.Uc(a)){var b=$APP.D(a),c=1<$APP.G(a);if($APP.Vc(b))throw $APP.Th("selectable cannot be statement!",
new $APP.q(null,1,[Gx,b],null));b=Z.g?Z.g(b):Z.call(null,b);var d=$APP.A(b);b=$APP.D(d);d=$APP.F(d);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[c?[$APP.t.g(b),$APP.fd(Hx,$APP.sn)&&$APP.Ba($APP.sn.g(Hx))?" ":" AS ",wx.l($APP.Jc(a),$APP.K([new $APP.q(null,1,[Ix,!0],null)]))].join(""):b],null),d)}return new $APP.S(null,1,5,$APP.U,[wx(a)],null)},Qx=function(a,b){b=$APP.M(b,0,null);var c=$APP.oe(b);b=$APP.O.h(c,$APP.sn);var d=$APP.O.h(c,Ix);if($APP.Vc(a))return b=new $APP.q(null,1,[Kx,!0],null),Lx.h?Lx.h(a,
b):Lx.call(null,a,b);if($APP.Uc(a)){var e=$APP.D(a),f=$APP.Jc(a);c=$APP.H.h(2,$APP.G(a));d=function(){var C=$APP.Ld(e);if(C){(C=$APP.H.h("*",$APP.Cg(e)))||(C=$APP.Cg(e),C=$APP.da(C,".*"));if(C){if(C=$APP.Ld(f)){C=$APP.Cg(f);var E=new $APP.xg(null,new $APP.q(null,2,["replace",null,"except",null],null),null);return E.g?E.g(C):E.call(null,C)}return C}return C}return C}();var g=2<$APP.G(a)&&$APP.Ba(d),k=$APP.Vc(e)?function(){var C=new $APP.q(null,1,[Kx,!0],null);return Lx.h?Lx.h(e,C):Lx.call(null,e,C)}():
Z.g?Z.g(e):Z.call(null,e);k=$APP.A(k);var l=$APP.D(k);k=$APP.F(k);var m=$APP.r(c?c:d)?$APP.Uc(f)?function(){var C=new $APP.q(null,1,[Ix,!0],null);var E=Mx.h?Mx.h(f,C):Mx.call(null,f,C);C=$APP.M(E,0,null);E=$APP.M(E,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[$APP.Yh(" ",C)],null),E)}():$APP.r(d)?$APP.Ia(function(C,E){var I=$APP.A(C);C=$APP.D(I);I=$APP.F(I);var R=$APP.M(E,0,null),T=$APP.M(E,1,null);if($APP.r(function(){var wa=$APP.Ld(R);return wa?(wa=$APP.H.h("except",$APP.Cg(R)))?T:wa:wa}()))E=
function(){var wa=new $APP.q(null,1,[Ix,!0],null);var Ca=Mx.h?Mx.h(T,wa):Mx.call(null,T,wa);wa=$APP.M(Ca,0,null);Ca=$APP.M(Ca,1,null);return new $APP.S(null,2,5,$APP.U,[[xx(R)," (",$APP.Yh(", ",wa),")"].join(""),Ca],null)}();else if($APP.r(function(){var wa=$APP.Ld(R);return wa?(wa=$APP.H.h("replace",$APP.Cg(R)))?T:wa:wa}()))E=function(){var wa=Nx.i?Nx.i(null,!0,T):Nx.call(null,null,!0,T),Ca=$APP.A(wa);wa=$APP.D(Ca);Ca=$APP.F(Ca);return new $APP.S(null,2,5,$APP.U,[[xx(R)," (",$APP.t.g(wa),")"].join(""),
Ca],null)}();else throw $APP.Th("bigquery * only supports except and replace",new $APP.q(null,2,[Ox,R,Px,T],null));var va=E;E=$APP.M(va,0,null);va=$APP.M(va,1,null);return $APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[$APP.r(C)?[$APP.t.g(C)," ",$APP.t.g(E)].join(""):E],null),I),va)},$APP.Oe,kx(2,2,$APP.nc(a))):Qx(f,$APP.K([new $APP.q(null,1,[Ix,!0],null)])):null;m=$APP.A(m);var n=$APP.D(m);m=$APP.F(m);var u=$APP.V.h,v=$APP.V.h,B=$APP.U;if(c)a=[$APP.t.g(l),$APP.r(b)?$APP.fd(Hx,$APP.sn)&&$APP.Ba($APP.sn.g(Hx))?
" ":" AS ":" ",$APP.t.g(n)].join("");else if($APP.r(d))a=[$APP.t.g(l)," ",$APP.t.g(n)].join("");else{if(g)throw $APP.Th("illegal syntax in select expression",new $APP.q(null,3,[$APP.Cj,e,Rx,f,Sx,$APP.F($APP.F(a))],null));a=l}return u.call($APP.V,v.call($APP.V,new $APP.S(null,1,5,B,[a],null),k),m)}return $APP.Ld(a)?$APP.r(d)?new $APP.S(null,1,5,$APP.U,[wx.l(a,$APP.K([c]))],null):Fx(a,$APP.K([c])):$APP.r($APP.r(d)?"string"===typeof a:d)?new $APP.S(null,1,5,$APP.U,[wx.l(a,$APP.K([c]))],null):Z.g?Z.g(a):
Z.call(null,a)},Tx=function(a){return $APP.Ia(function(b,c){var d=$APP.M(b,0,null);b=$APP.M(b,1,null);var e=$APP.A(c);c=$APP.D(e);e=$APP.F(e);return new $APP.S(null,2,5,$APP.U,[$APP.Ed.h(d,c),e?$APP.V.h(b,e):b],null)},new $APP.S(null,2,5,$APP.U,[$APP.Oe,$APP.Oe],null),a)},Ux=function(a,b){var c=Tx($APP.Q.h(function(d){return Lx.g?Lx.g(d):Lx.call(null,d)},b));b=$APP.M(c,0,null);c=$APP.M(c,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[$APP.Yh([" ",xx(a)," "].join(""),b)],null),c)},Mx=function(a){for(var b=
[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return Vx(arguments[0],1<b.length?new $APP.jc(b.slice(1),0,null):null)},Vx=function(a,b){var c=$APP.M(b,0,null);if(!$APP.Uc(a))throw $APP.Th(["format-expr-list expects a sequence of expressions, found: ",$APP.t.g($APP.Ea(a))].join(""),new $APP.q(null,1,[Wx,a],null));return Tx($APP.Q.h(function(d){return Z.h?Z.h(d,c):Z.call(null,d,c)},a))},Zx=function(a,b){b=Vx(b,$APP.K([new $APP.q(null,1,[Xx,$APP.H.h(Yx,a)],null)]));a=$APP.M(b,
0,null);b=$APP.M(b,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[["(",$APP.Yh(", ",a),")"].join("")],null),b)},Nx=function(a,b,c){if($APP.Uc(c)){var d=Tx($APP.Q.h(function(f){return Qx(f,$APP.K([new $APP.q(null,1,[$APP.sn,b],null)]))},c)),e=$APP.M(d,0,null);d=$APP.M(d,1,null);if(!$APP.H.h($APP.Nn,$x)&&$APP.Rc(c))throw $APP.Th([$APP.t.g(a)," empty column list is illegal"].join(""),new $APP.q(null,1,[Ox,$APP.V.h(new $APP.S(null,1,5,$APP.U,[a],null),c)],null));return $APP.V.h(new $APP.S(null,1,
5,$APP.U,[[$APP.r(a)?[$APP.t.g(a)," "].join(""):null,$APP.Yh(", ",e)].join("")],null),d)}c=Qx(c,$APP.K([new $APP.q(null,1,[$APP.sn,b],null)]));e=$APP.A(c);c=$APP.D(e);d=$APP.F(e);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[$APP.r(a)?[$APP.t.g(a)," "].join(""):null,$APP.t.g(c)].join("")],null),d)},jy=function(a,b){var c=Nx,d=xx(a),e=new $APP.xg(null,new $APP.q(null,10,[ay,null,by,null,cy,null,dy,null,ey,null,fy,null,gy,null,hy,null,iy,null,$APP.Qm,null],null),null);a=e.g?e.g(a):e.call(null,a);return c(d,
a,b)},ly=function(a,b){a=$APP.A(b);b=$APP.D(a);a=$APP.F(a);b=$APP.V.h(new $APP.S(null,1,5,$APP.U,[ky],null),b);b=Z.g?Z.g(b):Z.call(null,b);b=$APP.A(b);var c=$APP.D(b);b=$APP.F(b);a=Nx([xx($APP.Qm)," ",$APP.t.g(c)].join(""),!0,a);c=$APP.A(a);a=$APP.D(c);c=$APP.F(c);return $APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[a],null),b),c)},py=function(a,b){b=$APP.A(b);var c=$APP.D(b);b=$APP.F(b);var d=$APP.Uc(c)?function(){function g(m){var n=$APP.Ld(m);return n?(m=yx(m),n=new $APP.xg(null,new $APP.q(null,
2,[my,null,ny,null],null),null),n.g?n.g(m):n.call(null,m)):n}var k=$APP.Fd(c),l=gx(g,k);k=$APP.He(g,k);if($APP.A(l)){if($APP.H.h(1,$APP.G(k)))return $APP.V.h($APP.ff(k),$APP.Fd(l));throw $APP.Th("unparseable TOP expression",new $APP.q(null,1,[oy,c],null));}return new $APP.S(null,1,5,$APP.U,[c],null)}():new $APP.S(null,1,5,$APP.U,[c],null),e=$APP.A(d);d=$APP.D(e);e=$APP.F(e);d=Z.g?Z.g(d):Z.call(null,d);d=$APP.A(d);var f=$APP.D(d);d=$APP.F(d);a=Nx([xx(a),"(",$APP.t.g(f),")",$APP.A(e)?" ":null,$APP.Yh(" ",
$APP.Q.h(xx,e))].join(""),!0,b);b=$APP.A(a);a=$APP.D(b);b=$APP.F(b);return $APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[a],null),d),b)},ry=function(a,b){var c=$APP.Uc(b)?b:new $APP.S(null,1,5,$APP.U,[b],null);b=$APP.M(c,0,null);c=$APP.M(c,1,null);c=$APP.r(c)?Z.g?Z.g(c):Z.call(null,c):null;var d=$APP.A(c);c=$APP.D(d);d=$APP.F(d);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",wx(b),$APP.r(c)?[" ",xx($APP.H.h($APP.Kn,a)?$APP.An:qy)," ",$APP.t.g(c)].join(""):null].join("")],null),d)},sy=function(a,
b,c){var d=Tx($APP.Q.h(function(e){var f=$APP.M(e,0,null),g=$APP.M(e,1,null);if($APP.Uc(f)){var k=$APP.Jc(f);k=Lx.g?Lx.g(k):Lx.call(null,k);var l=$APP.A(k);k=$APP.D(l);l=$APP.F(l);f=$APP.V.h(new $APP.S(null,1,5,$APP.U,[[wx($APP.D(f))," ",$APP.t.g(k)].join("")],null),l)}else f=new $APP.S(null,1,5,$APP.U,[wx(f)],null);k=$APP.A(f);f=$APP.D(k);k=$APP.F(k);g=Lx.g?Lx.g(g):Lx.call(null,g);g=$APP.A(g);l=$APP.D(g);g=$APP.F(g);e=new $APP.S(null,1,5,$APP.U,[[$APP.t.g(f)," ",$APP.t.g(c.g?c.g(e):c.call(null,e)),
" ",["(",$APP.t.g(l),")"].join("")].join("")],null);e=k?$APP.V.h(e,k):e;return g?$APP.V.h(e,g):e},b));b=$APP.M(d,0,null);d=$APP.M(d,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",$APP.Yh(", ",b)].join("")],null),d)},ty=function(a,b){return jy(a,new $APP.S(null,1,5,$APP.U,[b],null))},yy=function(a,b){if($APP.Uc(b)){if($APP.Vc($APP.Jc(b))){var c=$APP.M(b,0,null),d=$APP.M(b,1,null);b=$APP.Uc(c)&&$APP.Uc($APP.Jc(c))?c:new $APP.S(null,1,5,$APP.U,[c],null);var e=$APP.M(b,0,null);b=$APP.M(b,
1,null);d=Lx.g?Lx.g(d):Lx.call(null,d);c=$APP.A(d);d=$APP.D(c);c=$APP.F(c);e=Jx(e);var f=$APP.A(e);e=$APP.D(f);f=$APP.F(f);var g=Tx($APP.Q.h(new $APP.z(function(){return Jx},uy,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),wy,"honey/sql.cljc",27,1,332,332,$APP.W(new $APP.S(null,1,5,$APP.U,[xy],null)),null,$APP.r(Jx)?Jx.F:null])),b)),k=$APP.M(g,0,null);g=$APP.M(g,1,null);return $APP.V.h($APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",$APP.t.g(e)," ",$APP.A(b)?["(",$APP.Yh(", ",k),") "].join(""):null,$APP.t.g(d)].join("")],null),f),g),c)}if($APP.Uc($APP.Jc(b)))return c=$APP.M(b,0,null),b=$APP.M(b,1,null),d=Jx(c),c=$APP.A(d),d=$APP.D(c),c=$APP.F(c),e=d,f=c,b=Tx($APP.Q.h(new $APP.z(function(){return Jx},
uy,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),wy,"honey/sql.cljc",27,1,332,332,$APP.W(new $APP.S(null,1,5,$APP.U,[xy],null)),null,$APP.r(Jx)?Jx.F:null])),b)),k=$APP.M(b,0,null),g=$APP.M(b,1,null),$APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",$APP.t.g(e)," (",$APP.Yh(", ",k),")"].join("")],null),f),g);b=Jx(b);d=$APP.A(b);b=$APP.D(d);c=$APP.F(d);d=b;return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",$APP.t.g(d)].join("")],null),c)}b=Jx(b);d=$APP.A(b);b=$APP.D(d);c=$APP.F(d);d=b;return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a),
" ",$APP.t.g(d)].join("")],null),c)},Cy=function(a,b){var c=$APP.Ia(function(d,e){var f=$APP.M(d,0,null);d=$APP.M(d,1,null);var g=$APP.M(e,0,null);e=$APP.M(e,1,null);g=Nx(xx($APP.H.h(zy,a)?Ay:a),!0,new $APP.S(null,1,5,$APP.U,[g],null));g=$APP.A(g);var k=$APP.D(g);g=$APP.F(g);f=$APP.Ed.h(f,k);if($APP.Uc(e)&&$APP.H.h(By,$APP.D(e)))return k=Tx($APP.Q.h(new $APP.z(function(){return Jx},uy,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,
1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),wy,"honey/sql.cljc",27,1,332,332,$APP.W(new $APP.S(null,1,5,$APP.U,[xy],null)),null,$APP.r(Jx)?Jx.F:null])),$APP.nc(e))),e=$APP.M(k,0,null),k=$APP.M(k,1,null),new $APP.S(null,2,5,$APP.U,[$APP.Ed.l(f,"USING",$APP.K([["(",$APP.Yh(", ",e),")"].join("")])),$APP.V.h($APP.V.h(d,g),k)],null);k=$APP.r(e)?Z.g?Z.g(e):Z.call(null,e):null;var l=$APP.A(k);k=$APP.D(l);l=$APP.F(l);return new $APP.S(null,2,5,$APP.U,[$APP.r(e)?$APP.Ed.l(f,"ON",$APP.K([k])):f,$APP.V.h($APP.V.h(d,g),l)],null)},new $APP.S(null,
2,5,$APP.U,[$APP.Oe,$APP.Oe],null),kx(2,2,b));b=$APP.M(c,0,null);c=$APP.M(c,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[$APP.Yh(" ",b)],null),c)},Gy=function(a,b){a=$APP.te($APP.Vc,b)?$APP.V.i($APP.Oe,$APP.tm.h($APP.tm.h($APP.Q.g(function(c){return $APP.Le($APP.Kg($APP.df,$APP.ef),$APP.K([c]))}),$APP.kh),$APP.Q.g($APP.fl)),b):ix($APP.Ld,b);if(!$APP.ve($APP.G(a)))throw $APP.Th(":join-by expects a sequence of join clauses",new $APP.q(null,1,[Dy,b],null));a=$APP.Ia(function(c,d){var e=$APP.M(c,
0,null);c=$APP.M(c,1,null);var f=$APP.M(d,0,null);f=$APP.M(f,0,null);d=$APP.M(d,1,null);d=$APP.M(d,0,null);var g=yx(f);g=yx(Ey.h?Ey.h(g,g):Ey.call(null,g,g));if(!$APP.r(Fy.g?Fy.g(g):Fy.call(null,g)))throw $APP.Th([":join-by found an invalid join type ",$APP.t.g(f)].join(""),$APP.ne);f=$APP.me([g,d]);f=Lx.g?Lx.g(f):Lx.call(null,f);d=$APP.A(f);f=$APP.D(d);d=$APP.F(d);return new $APP.S(null,2,5,$APP.U,[$APP.Ed.h(e,f),$APP.V.h(c,d)],null)},new $APP.S(null,2,5,$APP.U,[$APP.Oe,$APP.Oe],null),lx(2,2,a));
b=$APP.M(a,0,null);a=$APP.M(a,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[$APP.Yh(" ",b)],null),a)},Hy=function(a,b){if(!$APP.Uc(b)||$APP.A(b)){b=Z.g?Z.g(b):Z.call(null,b);var c=$APP.A(b);b=$APP.D(c);c=$APP.F(c);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",$APP.t.g(b)].join("")],null),c)}return $APP.Oe},Iy=function(a,b){var c=Mx(b);b=$APP.M(c,0,null);c=$APP.M(c,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",$APP.Yh(", ",b)].join("")],null),c)},Ky=function(a,b){var c=
$APP.Q.h(function(e){return $APP.Uc(e)?$APP.Jc(e):null},b),d=Mx($APP.Q.h(function(e){return $APP.Uc(e)?$APP.D(e):e},b));b=$APP.M(d,0,null);d=$APP.M(d,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",$APP.Yh(", ",$APP.Q.i(function(e,f){return[$APP.t.g(e)," ",xx($APP.r(f)?f:Jy)].join("")},b,c))].join("")],null),d)},$y=function(a,b){var c=$APP.Uc(b)?b:new $APP.S(null,1,5,$APP.U,[b],null);b=$APP.M(c,0,null);var d=$APP.M(c,1,null);c=$APP.M(c,2,null);return new $APP.S(null,1,5,$APP.U,[[xx(a),
" ",xx(b),$APP.r(d)?[$APP.r(function(){var e=$APP.Ld(d);if(e){e=yx(d);var f=new $APP.xg(null,new $APP.q(null,3,[Ly,null,My,null,Ny,null],null),null);return f.g?f.g(e):f.call(null,e)}return e}())?[" ",xx(d)].join(""):$APP.Uc(d)?[" OF ",$APP.Yh(", ",$APP.Q.h(new $APP.z(function(){return wx},Oy,$APP.kg([$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,Py,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),Qy,"honey/sql.cljc",20,new $APP.q(null,6,[Ry,!0,Sy,1,Ty,1,Uy,new $APP.S(null,1,5,$APP.U,[$APP.W(Vy,new $APP.S(null,1,5,$APP.U,[new $APP.q(null,1,[Wy,new $APP.S(null,2,5,$APP.U,[Xy,Yy],null)],null)],null))],null),$APP.Rm,$APP.W(new $APP.S(null,3,5,$APP.U,[Vy,$APP.Dn,new $APP.S(null,1,5,$APP.U,[new $APP.q(null,1,[Wy,new $APP.S(null,2,5,$APP.U,[Xy,Yy],null)],null)],null)],null)),Zy,$APP.W(null)],null),1,209,209,$APP.W(new $APP.S(null,3,5,$APP.U,[Vy,$APP.Dn,new $APP.S(null,1,5,$APP.U,[new $APP.q(null,
1,[Wy,new $APP.S(null,2,5,$APP.U,[Xy,Yy],null)],null)],null)],null)),"Given a simple SQL entity (a keyword or symbol -- or string),\n  return the equivalent SQL fragment (as a string -- no parameters).\n\n  Handles quoting, splitting at / or ., replacing - with _ etc.",$APP.r(wx)?wx.F:null])),d))].join(""):[" OF ",wx(d)].join(""),$APP.r(c)?[" ",xx(c)].join(""):null].join(""):null].join("")],null)},ez=function(a,b){var c=$APP.Uc(b)?$APP.D($APP.He($APP.Ld,b)):null;if($APP.fd(new $APP.xg(null,new $APP.q(null,
2,[az,null,$APP.Kh,null],null),null),b))return new $APP.S(null,1,5,$APP.U,[[xx(b)," ",xx(a)].join("")],null);if($APP.Rc(b))return new $APP.S(null,1,5,$APP.U,[[xx(a)," ()"].join("")],null);if($APP.Uc(c)){var d=$APP.Q.h($APP.G,$APP.Me($APP.Uc,b));c=$APP.r($APP.de($APP.H,d))?b:function(){var g=$APP.A(d)?$APP.de(bz,d):null;return $APP.Q.h(function(k){return $APP.Uc(k)?$APP.pi.h(g,$APP.Ke.h(k,$APP.Je(null))):k},b)}();var e=$APP.Ia(function(g,k){var l=$APP.M(g,0,null);g=$APP.M(g,1,null);var m=$APP.M(k,
0,null);k=$APP.M(k,1,null);return new $APP.S(null,2,5,$APP.U,[$APP.Ed.h(l,$APP.Uc(m)?["(",$APP.Yh(", ",m),")"].join(""):m),$APP.V.h(g,k)],null)},new $APP.S(null,2,5,$APP.U,[$APP.Oe,$APP.Oe],null),$APP.Q.h(function(g){return $APP.Uc(g)?Mx(g):new $APP.S(null,1,5,$APP.U,[xx(g)],null)},c));c=$APP.M(e,0,null);e=$APP.M(e,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",$APP.Yh(", ",c)].join("")],null),e)}if($APP.Vc(c)){c=$APP.qg($APP.D(b));e=$APP.V.i($APP.zg,$APP.tm.h($APP.Q.g($APP.qg),$APP.kh),
$APP.Me($APP.Vc,b));var f=$APP.H.h($APP.Ag(c),e)?c:e;e=$APP.Ia(function(g,k){var l=$APP.M(g,0,null);g=$APP.M(g,1,null);var m=$APP.M(k,0,null);k=$APP.M(k,1,null);return new $APP.S(null,2,5,$APP.U,[$APP.Ed.h(l,$APP.Uc(m)?["(",$APP.Yh(", ",m),")"].join(""):m),$APP.r(k)?$APP.V.h(g,k):k],null)},new $APP.S(null,2,5,$APP.U,[$APP.Oe,$APP.Oe],null),$APP.Q.h(function(g){return $APP.Vc(g)?Mx($APP.Q.h(function(k){return $APP.O.i(g,k,$APP.fd(cz,k)?new $APP.S(null,1,5,$APP.U,[$APP.Kh],null):null)},f)):new $APP.S(null,
1,5,$APP.U,[xx(g)],null)},b));c=$APP.M(e,0,null);e=$APP.M(e,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[["(",$APP.Yh(", ",$APP.Q.h(function(g){return wx.l(g,$APP.K([new $APP.q(null,1,[Xx,!0],null)]))},f)),") ",xx(a)," ",$APP.Yh(", ",c)].join("")],null),e)}throw $APP.Th(":values expects sequences or maps",new $APP.q(null,1,[dz,$APP.D(b)],null));},hz=function(a,b){var c=$APP.td(function(d,e,f){var g=$APP.M(d,0,null);d=$APP.M(d,1,null);f=Z.g?Z.g(f):Z.call(null,f);var k=$APP.A(f);f=$APP.D(k);
k=$APP.F(k);return new $APP.S(null,2,5,$APP.U,[$APP.Ed.h(g,[wx.l(e,$APP.K([new $APP.q(null,1,[Xx,!$APP.H.h(fz,gz.g(Hx))],null)]))," \x3d ",$APP.t.g(f)].join("")),k?$APP.V.h(d,k):d],null)},new $APP.S(null,2,5,$APP.U,[$APP.Oe,$APP.Oe],null),b);b=$APP.M(c,0,null);c=$APP.M(c,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",$APP.Yh(", ",b)].join("")],null),c)},lz=function(a,b){for(;;){if($APP.Vc(b)){if($APP.fd(b,iz)||$APP.fd(b,$APP.Im)){var c=$APP.Yh(", ",$APP.Q.h(function(){return function(g){g=
wx.l(g,$APP.K([new $APP.q(null,1,[Xx,!0],null)]));return[g," \x3d EXCLUDED.",g].join("")}}(a,b),function(){var g=iz.g(b);return $APP.r(g)?g:$APP.Im.g?$APP.Im.g(b):$APP.Im.call(null,b)}())),d=function(){var g=jz.g(b);return $APP.r(g)?g:kz.g?kz.g(b):kz.call(null,b)}(),e=$APP.r(d)?function(){var g=new $APP.q(null,1,[jz,d],null);return Lx.g?Lx.g(g):Lx.call(null,g)}():null,f=$APP.A(e);e=$APP.D(f);f=$APP.F(f);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a)," ",c,$APP.r(e)?[" ",$APP.t.g(e)].join(""):
null].join("")],null),f)}return hz(a,b)}if($APP.Uc(b))e=hx(b),c=$APP.M(e,0,null),e=$APP.M(e,1,null),b=$APP.A(c)?c=new $APP.q(null,2,[iz,c,jz,jz.g($APP.D(e))],null):c=$APP.D(e);else return c=wx.l(b,$APP.K([new $APP.q(null,1,[Xx,!0],null)])),new $APP.S(null,1,5,$APP.U,[[xx(a)," ",c," \x3d EXCLUDED.",c].join("")],null)}},mz=function(a,b){var c=Ex;Ex=!0;try{var d=Lx.g?Lx.g(a):Lx.call(null,a),e=$APP.A(d),f=$APP.D(e),g=$APP.F(e);if($APP.A(g))throw $APP.Th(["parameters are not accepted in ",$APP.t.g(b)].join(""),
new $APP.q(null,2,[Ox,a,Ax,g],null));return f}finally{Ex=c}},oz=function(a,b){var c=Ex;Ex=!0;try{var d=Z.g?Z.g(a):Z.call(null,a),e=$APP.A(d),f=$APP.D(e),g=$APP.F(e);if($APP.A(g))throw $APP.Th(["parameters are not accepted in ",$APP.t.g(b)].join(""),new $APP.q(null,2,[nz,a,Ax,g],null));return f}finally{Ex=c}},pz=function(a,b){return $APP.Uc(b)?new $APP.S(null,1,5,$APP.U,[[xx(a)," ",wx($APP.D(b)),function(){var c=$APP.F(b);return c?[" ",$APP.Yh(", ",$APP.Q.h(function(d){return mz(d,"column/index operations")},
c))].join(""):null}()].join("")],null):new $APP.S(null,1,5,$APP.U,[[xx(a)," ",wx(b)].join("")],null)},qz=function(a,b){return function e(d){return new $APP.Nd(null,function(){for(;;){var f=$APP.A(d);if(f){var g=f;if($APP.Yc(g)){var k=$APP.Qb(g),l=$APP.G(k),m=$APP.Qd(l);return function(){for(var u=0;;)if(u<l){var v=$APP.Mc(k,u);$APP.Ud(m,$APP.Vc(v)?mz(v,b):$APP.Uc(v)?$APP.Yh(" ",$APP.Q.h(function(){return function(B){return $APP.Ld(B)?xx(B):oz(B,b)}}(u,v,k,l,m,g,f),v)):xx(v));u+=1}else return!0}()?
$APP.Td($APP.Vd(m),e($APP.Rb(g))):$APP.Td($APP.Vd(m),null)}var n=$APP.D(g);return $APP.Hd($APP.Vc(n)?mz(n,b):$APP.Uc(n)?$APP.Yh(" ",$APP.Q.h(function(){return function(u){return $APP.Ld(u)?xx(u):oz(u,b)}}(n,g,f),n)):xx(n),e($APP.nc(g)))}return null}},null,null)}(a)},sz=function(a,b){function c(g){return $APP.Ld(g)||"string"===typeof g}a=$APP.Uc(a)?a:new $APP.S(null,1,5,$APP.U,[a],null);var d=gx(c,a);a=$APP.He(c,a);var e=$APP.Kc(d),f=$APP.H.h(rz,yx(e))?new $APP.S(null,3,5,$APP.U,[$APP.Bg($APP.Bg(d)),
$APP.Kc($APP.Bg(d)),e],null):new $APP.S(null,3,5,$APP.U,[$APP.Bg(d),$APP.Kc(d),null],null);d=$APP.M(f,0,null);e=$APP.M(f,1,null);f=$APP.M(f,2,null);return $APP.V.h(new $APP.S(null,3,5,$APP.U,[$APP.Yh(" ",$APP.Q.h(xx,d)),wx(e),$APP.r(f)?xx(f):null],null),qz(a,b))},vz=function(a,b,c,d){c=sz(c,[xx(a)," options"].join(""));var e=$APP.A(c);c=$APP.D(e);var f=$APP.F(e);e=$APP.D(f);var g=$APP.F(f);f=$APP.D(g);g=$APP.F(g);return new $APP.S(null,1,5,$APP.U,[$APP.Yh(" ",$APP.Ne($APP.za,$APP.Ed.h($APP.V.h(new $APP.S(null,
6,5,$APP.U,[xx(a),$APP.H.h(tz,a)&&$APP.A(c)?c:null,xx(b),f,$APP.H.h(uz,a)&&$APP.A(c)?c:null,e],null),g),$APP.r(d)?xx(d):null)))],null)},zz=function(a,b){a=$APP.Uc(b)?$APP.D(b):b;return new $APP.S(null,1,5,$APP.U,[$APP.Yh(" ",$APP.Ne($APP.za,new $APP.S(null,3,5,$APP.U,[xx(wz),$APP.r(a)?null:xx(xz),xx(yz)],null)))],null)},Cz=function(a){a=$APP.Uc(a)?a:new $APP.S(null,1,5,$APP.U,[a],null);var b=gx($APP.Ld,a);a=$APP.He($APP.Ld,a);var c=$APP.r(function(){var e=$APP.D(b),f=new $APP.xg(null,new $APP.q(null,
2,[Az,null,Bz,null],null),null);return f.g?f.g(e):f.call(null,e)}())?b:$APP.Hd(null,b),d=$APP.A(c);c=$APP.D(d);d=$APP.F(d);return $APP.V.h(new $APP.S(null,2,5,$APP.U,[$APP.r(c)?xx(Az):null,$APP.Yh(", ",$APP.Q.h(new $APP.z(function(){return wx},Oy,$APP.kg([$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,Py,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),Qy,"honey/sql.cljc",20,new $APP.q(null,6,[Ry,!0,Sy,1,Ty,1,Uy,new $APP.S(null,1,5,$APP.U,[$APP.W(Vy,new $APP.S(null,1,5,$APP.U,[new $APP.q(null,1,[Wy,new $APP.S(null,2,5,$APP.U,[Xy,Yy],null)],null)],null))],null),$APP.Rm,$APP.W(new $APP.S(null,3,5,$APP.U,[Vy,$APP.Dn,new $APP.S(null,1,5,$APP.U,[new $APP.q(null,1,[Wy,new $APP.S(null,2,5,$APP.U,[Xy,Yy],null)],null)],null)],null)),Zy,$APP.W(null)],null),1,209,209,$APP.W(new $APP.S(null,3,5,$APP.U,[Vy,$APP.Dn,new $APP.S(null,1,5,$APP.U,[new $APP.q(null,
1,[Wy,new $APP.S(null,2,5,$APP.U,[Xy,Yy],null)],null)],null)],null)),"Given a simple SQL entity (a keyword or symbol -- or string),\n  return the equivalent SQL fragment (as a string -- no parameters).\n\n  Handles quoting, splitting at / or ., replacing - with _ etc.",$APP.r(wx)?wx.F:null])),d))],null),qz(a,"DROP options"))},Dz=function(a,b){b=Cz(b);var c=$APP.A(b);b=$APP.D(c);var d=$APP.F(c);c=$APP.D(d);d=$APP.F(d);return new $APP.S(null,1,5,$APP.U,[$APP.Yh(" ",$APP.Ne($APP.za,$APP.V.h(new $APP.S(null,
3,5,$APP.U,[xx(a),b,c],null),d)))],null)},Fz=function(a){$APP.Be(Ez,!0);return $APP.Yh(" ",$APP.Hd(oz($APP.D(a),"column operation"),$APP.Q.h(function(b){var c=Ez;Ez=$APP.Ae(!1);try{var d=oz(b,"column operation");return $APP.Ba($APP.w(Ez))?d.toUpperCase():d}finally{Ez=c}},$APP.nc(a))))},Jz=function(a,b){return new $APP.S(null,1,5,$APP.U,[["(",$APP.Yh(", ",$APP.Q.h(new $APP.z(function(){return Fz},Gz,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,
$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),Hz,"honey/sql.cljc",28,1,941,941,$APP.W(new $APP.S(null,1,5,$APP.U,[Iz],null)),null,$APP.r(Fz)?Fz.F:null])),b)),")"].join("")],null)},Lz=function(a,b){return $APP.fd(new $APP.xg(null,new $APP.q(null,2,[Kz,null,rz,null],null),null),$APP.Kc(b))?new $APP.S(null,1,5,$APP.U,[[xx(a)," ",xx(rz)," ",Fz($APP.Bg(b))].join("")],null):new $APP.S(null,1,5,$APP.U,[[xx(a)," ",Fz(b)].join("")],null)},Mz=function(a,b){var c=$APP.M(b,0,null);b=$APP.M(b,1,null);return new $APP.S(null,1,5,$APP.U,[[xx(a)," ",wx(c),
" TO ",wx(b)].join("")],null)},Nz=function(a){if($APP.Uc(a)){var b=$APP.Ia(function(c,d){var e=$APP.M(c,0,null);c=$APP.M(c,1,null);if($APP.Uc(d)){d=Z.g?Z.g(d):Z.call(null,d);var f=$APP.A(d);d=$APP.D(f);f=$APP.F(f);return new $APP.S(null,2,5,$APP.U,[$APP.Ed.h(e,d),$APP.V.h(c,f)],null)}return new $APP.S(null,2,5,$APP.U,[$APP.Ed.h(e,d),c],null)},new $APP.S(null,2,5,$APP.U,[$APP.Oe,$APP.Oe],null),a);a=$APP.M(b,0,null);b=$APP.M(b,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[dx(a)],null),b)}return new $APP.S(null,
1,5,$APP.U,[a],null)},Oz=function(a){return function(b,c){if(!$APP.H.h($APP.Nn,$x)&&!$APP.A(jz.g(sx)))throw $APP.Th([xx(b)," without a non-empty WHERE clause is dangerous"].join(""),new $APP.q(null,2,[Ox,b,jz,jz.g(sx)],null));return a.h?a.h(b,c):a.call(null,b,c)}},Pz=function(a){if(a instanceof $APP.P){var b=$APP.Kd(a);return $APP.r(b)?$APP.ch.h(b,$APP.Cg(a)):$APP.ch.g($APP.Cg(a))}return a},Lx=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return Qz(arguments[0],
1<b.length?new $APP.jc(b.slice(1),0,null):null)},Qz=function(a,b){b=$APP.M(b,0,null);b=$APP.oe(b);var c=$APP.O.h(b,Ix),d=$APP.O.h(b,Kx),e=$APP.O.h(b,Rz);b=sx;sx=a;try{var f=$APP.Ia(function(m,n){var u=$APP.M(m,0,null),v=$APP.M(m,1,null),B=$APP.M(m,2,null);m=function(){var E=n.g?n.g(B):n.call(null,B);return null==E?(E=Pz(n),$APP.O.h(B,E)):E}();if(null==m)return new $APP.S(null,3,5,$APP.U,[u,v,B],null);var C=function(){var E=$APP.w(Sz);return n.g?n.g(E):n.call(null,E)}();m=C.h?C.h(n,m):C.call(null,
n,m);C=$APP.A(m);m=$APP.D(C);C=$APP.F(C);return new $APP.S(null,3,5,$APP.U,[$APP.Ed.h(u,m),C?$APP.V.h(v,C):v,$APP.Ik.l(B,n,$APP.K([Pz(n)]))],null)},new $APP.S(null,3,5,$APP.U,[$APP.Oe,$APP.Oe,a],null),Tz),g=$APP.M(f,0,null),k=$APP.M(f,1,null),l=$APP.M(f,2,null);if($APP.A(l))throw $APP.Th(["These SQL clauses are unknown or have nil values: ",$APP.Yh(", ",$APP.qg(l))].join(""),l);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[function(){var m=$APP.Yh($APP.r(e)?"\n":" ",$APP.Me($APP.A,g));m=$APP.r(e)?["\n",
m,"\n"].join(""):m;return $APP.r($APP.r(d)?$APP.Ba(c):d)?["(",m,")"].join(""):m}()],null),k)}finally{sx=b}},Uz=function(a,b){var c=$APP.Qc(a);return $APP.r(c)?(c=Cx.g(c),$APP.r(c)?c.h?c.h(a,b):c.call(null,a,b):a):a},Xz=function(a,b){var c=$APP.M(b,0,null),d=$APP.M(b,1,null);b=function(){var m=new $APP.q(null,1,[Kx,!0],null);return Z.h?Z.h(c,m):Z.call(null,c,m)}();var e=$APP.A(b);b=$APP.D(e);e=$APP.F(e);var f=function(){var m=new $APP.q(null,1,[Kx,!0],null);return Z.h?Z.h(d,m):Z.call(null,d,m)}();
f=$APP.A(f);var g=$APP.D(f),k=$APP.F(f),l=Uz($APP.D(k),$APP.ne);if($APP.r(function(){var m=$APP.Qc($APP.D(k));return $APP.r(m)?(m=Cx.g($APP.Qc($APP.D(k))),$APP.r(m)?Vz:m):m}()))throw $APP.Th("SQL that includes IN () expressions cannot be cached",$APP.ne);if(!$APP.H.h($APP.Nn,$x)){if($APP.Uc(d)&&$APP.Rc(d)||$APP.Uc(l)&&$APP.Rc(l))throw $APP.Th("IN () empty collection is illegal",new $APP.q(null,1,[Ox,new $APP.S(null,3,5,$APP.U,[a,c,d],null)],null));if($APP.r(function(){var m=$APP.H.h(Wz,$x);return m?
(m=(m=$APP.Uc(d))?$APP.ue($APP.za,d):m,$APP.r(m)?m:(m=$APP.Uc(l))?$APP.ue($APP.za,l):m):m}()))throw $APP.Th("IN (NULL) does not match",new $APP.q(null,1,[Ox,new $APP.S(null,3,5,$APP.U,[a,c,d],null)],null));}return $APP.H.h("?",g)&&$APP.H.h(1,$APP.G(k))&&$APP.Sc(l)?(f=["(",$APP.Yh(", ",fx($APP.G(l))),")"].join(""),$APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[[$APP.t.g(b)," ",xx(a)," ",f].join("")],null),e),l)):$APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[[$APP.t.g(b)," ",xx(a)," ",$APP.t.g(g)].join("")],
null),e),k)},Yz=function(a,b){return new $APP.S(null,1,5,$APP.U,[[xx(a),$APP.A(b)?["(",$APP.Yh(", ",$APP.Q.h(function(c){return oz(c,"column/index operation")},b)),")"].join(""):null].join("")],null)},Zz=function(a,b){return new $APP.S(null,1,5,$APP.U,[[xx(a),$APP.A(b)?[" ",$APP.t.g(oz($APP.D(b),"column/index operation")),function(){var c=$APP.F(b);return c?["(",$APP.Yh(", ",$APP.Q.h(function(d){return oz(d,"column/index operation")},c)),")"].join(""):null}()].join(""):null].join("")],null)},$z=function(a,
b){return new $APP.S(null,1,5,$APP.U,[[xx(a),$APP.A(b)?[function(){var c=$APP.D(b);return $APP.r(c)?[" ",$APP.t.g(oz(c,"column/index operation"))].join(""):null}(),function(){var c=$APP.F(b);return c?["(",$APP.Yh(", ",$APP.Q.h(function(d){return oz(d,"column/index operation")},c)),")"].join(""):null}()].join(""):null].join("")],null)},aA=function(a,b){var c=$APP.Ia(function(d,e){var f=$APP.M(d,0,null);d=$APP.M(d,1,null);var g=$APP.M(e,0,null),k=$APP.M(e,1,null);e=Z.g?Z.g(g):Z.call(null,g);g=$APP.A(e);
e=$APP.D(g);g=$APP.F(g);k=Qz(k,$APP.K([new $APP.q(null,1,[Kx,!0],null)]));var l=$APP.A(k);k=$APP.D(l);l=$APP.F(l);return new $APP.S(null,2,5,$APP.U,[$APP.Ed.h(f,[$APP.t.g(e)," ",xx(a)," ",$APP.t.g(k)].join("")),$APP.V.h($APP.V.h(d,g),l)],null)},new $APP.S(null,2,5,$APP.U,[$APP.Oe,$APP.Oe],null),lx(2,2,b));b=$APP.M(c,0,null);c=$APP.M(c,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[$APP.Yh(", ",b)],null),c)},hA=function(a,b){var c=(a=$APP.H.h(bA,a))?function(){var g=$APP.D(b);return Z.g?Z.g(g):
Z.call(null,g)}():null,d=$APP.A(c);c=$APP.D(d);d=$APP.F(d);var e=$APP.Ia(function(g,k){var l=$APP.M(g,0,null);g=$APP.M(g,1,null);var m=$APP.M(k,0,null),n=$APP.M(k,1,null);k=$APP.H.h($APP.zn,m)?null:Z.g?Z.g(m):Z.call(null,m);var u=$APP.A(k);k=$APP.D(u);u=$APP.F(u);n=Z.g?Z.g(n):Z.call(null,n);var v=$APP.A(n);n=$APP.D(v);v=$APP.F(v);return new $APP.S(null,2,5,$APP.U,[$APP.H.h($APP.zn,m)||$APP.H.h(cA,m)?$APP.Ed.l(l,xx($APP.zn),$APP.K([n])):$APP.Ed.l(l,xx(dA),$APP.K([k,xx(eA),n])),$APP.V.h($APP.V.h(g,
u),v)],null)},new $APP.S(null,2,5,$APP.U,[$APP.Oe,$APP.Oe],null),lx(2,2,a?$APP.nc(b):b)),f=$APP.M(e,0,null);e=$APP.M(e,1,null);return $APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(fA)," ",a?[$APP.t.g(c)," "].join(""):null,$APP.Yh(" ",f)," ",xx(gA)].join("")],null),d),e)},Z=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return iA(arguments[0],1<b.length?new $APP.jc(b.slice(1),0,null):null)},iA=function(a,b){b=$APP.M(b,0,null);b=$APP.oe(b);var c=$APP.O.h(b,
Kx);if($APP.Ld(a))return Fx(a,$APP.K([b]));if($APP.Vc(a))return Qz(a,$APP.K([$APP.ug.i(b,Kx,!0)]));if($APP.Uc(a)){var d=yx($APP.D(a));if(d instanceof $APP.P){if($APP.fd($APP.w(jA),d)){if($APP.fd($APP.w(kA),d)){a=$APP.fd($APP.w(lA),d)?$APP.Ne($APP.za,a):a;a=Tx($APP.Q.h(function(n){return iA(n,$APP.K([new $APP.q(null,1,[Kx,!0],null)]))},$APP.nc(a)));var e=$APP.M(a,0,null);a=$APP.M(a,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[function(){var n=$APP.Yh([" ",xx(d)," "].join(""),e);return $APP.r(c)?
["(",n,")"].join(""):n}()],null),a)}b=$APP.A(a);$APP.D(b);b=$APP.F(b);var f=$APP.D(b);b=$APP.F(b);var g=$APP.D(b);b=$APP.F(b);if($APP.A(b))throw $APP.Th(["only binary ",$APP.t.g(d)," is supported"].join(""),new $APP.q(null,1,[nz,a],null));a=iA(f,$APP.K([new $APP.q(null,1,[Kx,!0],null)]));a=$APP.A(a);var k=$APP.D(a);a=$APP.F(a);b=iA(g,$APP.K([new $APP.q(null,1,[Kx,!0],null)]));b=$APP.A(b);var l=$APP.D(b);b=$APP.F(b);var m=$APP.O.i(mA,d,d);return $APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[function(){var n=
new $APP.xg(null,new $APP.q(null,2,[nA,null,oA,null],null),null);n=n.g?n.g(m):n.call(null,m);n=$APP.r($APP.r(n)?null==f||null==g:n)?[$APP.t.g(null==f?null==g?"NULL":l:k),$APP.H.h(oA,m)?" IS NULL":" IS NOT NULL"].join(""):[$APP.t.g(k)," ",xx(m)," ",$APP.t.g(l)].join("");return $APP.r(c)?["(",n,")"].join(""):n}()],null),a),b)}if($APP.fd(new $APP.xg(null,new $APP.q(null,2,[pA,null,$APP.An,null],null),null),d))return a=Xz(d,$APP.nc(a)),a=$APP.A(a),b=$APP.D(a),a=$APP.F(a),$APP.V.h(new $APP.S(null,1,5,
$APP.U,[$APP.r(c)?["(",$APP.t.g(b),")"].join(""):b],null),a);if($APP.fd($APP.w(qA),d))return b=$APP.O.h($APP.w(qA),d),a=$APP.nc(a),b.h?b.h(d,a):b.call(null,d,a);b=$APP.nc(a);a=Mx(b);e=$APP.M(a,0,null);a=$APP.M(a,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(d),$APP.H.h(1,$APP.G(b))&&$APP.Vc($APP.D(b))&&$APP.H.h(1,$APP.G(e))?[" ",$APP.t.g($APP.D(e))].join(""):["(",$APP.Yh(", ",e),")"].join("")].join("")],null),a)}a=Mx(a);e=$APP.M(a,0,null);a=$APP.M(a,1,null);return $APP.V.h(new $APP.S(null,
1,5,$APP.U,[["(",$APP.Yh(", ",e),")"].join("")],null),a)}return $APP.$c(a)?new $APP.S(null,1,5,$APP.U,[$APP.t.g(a).toUpperCase()],null):null==a?new $APP.S(null,1,5,$APP.U,["NULL"],null):$APP.r(Ex)?new $APP.S(null,1,5,$APP.U,[ox(a)],null):new $APP.S(null,2,5,$APP.U,["?",a],null)},tA=function(a){if(!$APP.fd($APP.w(rA),a)){a=["Invalid dialect: ",$APP.t.g(a)].join("");var b=$APP.qg($APP.w(rA));b=$APP.kd($APP.gd,b);throw $APP.Th(a,new $APP.q(null,1,[sA,$APP.ff(b)],null));}return a},HA=function(a){var b=
new $APP.q(null,1,[uA,!0],null),c=vA.g(b),d=$APP.fd(b,gz),e=d?$APP.O.h($APP.w(rA),tA(gz.g(b))):null,f=Hx,g=Vz,k=$x,l=Tz,m=Ex,n=wA,u=xA,v=zx,B=cz,C=d?e:$APP.w(yA),E=$APP.fd(b,zA)?zA.g(b):$APP.Nn,I=d?function(){var Ca=AA.g(e);if($APP.r(Ca)){var Fb=$APP.w(BA);return Ca.g?Ca.g(Fb):Ca.call(null,Fb)}return $APP.w(CA)}():$APP.w(CA),R=$APP.fd(b,uA)?uA.g(b):null;d=$APP.fd(b,DA)?DA.g(b):d?!0:$APP.w(EA);var T=$APP.fd(b,FA)?FA.g(b):null,va=Ax.g(b),wa=GA.g(b);Hx=C;Vz=c;$x=E;Tz=I;Ex=R;wA=d;xA=T;zx=va;cz=wa;try{if($APP.r(c))throw $APP.Th("cached queries are not supported in ClojureScript",
b);return $APP.Pe(function(Ca){return Uz(Ca,b)},Qz(a,$APP.K([b])))}finally{cz=B,zx=v,xA=u,wA=n,Ex=m,Tz=l,$x=k,Vz=g,Hx=f}},IA=function(a,b,c){a=yx(a);c=yx(c);var d=yx(b);d=d instanceof $APP.P?$APP.O.h($APP.w(Sz),d):b;if(!$APP.r($APP.r(d)?$APP.Oc(d)||d instanceof $APP.z&&$APP.Oc($APP.w(d)):d))throw $APP.Th("The formatter must be a function or existing clause",new $APP.q(null,1,[$APP.zi,$APP.Ea(b)],null));$APP.hh.A(BA,qx,a,c);$APP.hh.A(CA,qx,a,c);return $APP.hh.A(Sz,$APP.ug,a,d)},JA=function(a){return $APP.V.h($APP.ne,
function(){return function d(c){return new $APP.Nd(null,function(){for(;;){var e=$APP.A(c);if(e){if($APP.Yc(e)){var f=$APP.Qb(e),g=$APP.G(f),k=$APP.Qd(g);a:for(var l=0;;)if(l<g){var m=$APP.Mc(f,l);m=new $APP.S(null,2,5,$APP.U,[$APP.Wg.g(m),a[m]],null);k.add(m);l+=1}else{f=!0;break a}return f?$APP.Td($APP.Vd(k),d($APP.Rb(e))):$APP.Td($APP.Vd(k),null)}k=$APP.D(e);return $APP.Hd(new $APP.S(null,2,5,$APP.U,[$APP.Wg.g(k),a[k]],null),d($APP.nc(e)))}return null}},null,null)}(Object.keys(a))}())},UA=function(a){var b=
HA(new $APP.q(null,2,[KA,new $APP.S(null,2,5,$APP.U,["artifacts",rz],null),LA,new $APP.S(null,6,5,$APP.U,[new $APP.S(null,3,5,$APP.U,[MA,NA,new $APP.S(null,1,5,$APP.U,[OA],null)],null),new $APP.S(null,3,5,$APP.U,[$APP.zi,$APP.Cn,new $APP.S(null,2,5,$APP.U,[PA,QA],null)],null),new $APP.S(null,3,5,$APP.U,[$APP.Dm,NA,new $APP.S(null,2,5,$APP.U,[PA,QA],null)],null),new $APP.S(null,3,5,$APP.U,[$APP.Km,$APP.Cn,new $APP.S(null,2,5,$APP.U,[PA,QA],null)],null),new $APP.S(null,3,5,$APP.U,[$APP.qn,$APP.Cn,new $APP.S(null,
2,5,$APP.U,[PA,QA],null)],null),new $APP.S(null,1,5,$APP.U,[new $APP.S(null,2,5,$APP.U,[RA,new $APP.S(null,4,5,$APP.U,[SA,$APP.Dm,$APP.Km,$APP.qn],null)],null)],null)],null)],null)),c=HA(new $APP.q(null,2,[KA,new $APP.S(null,2,5,$APP.U,["subtitles",rz],null),LA,new $APP.S(null,6,5,$APP.U,[new $APP.S(null,3,5,$APP.U,[MA,NA,new $APP.S(null,2,5,$APP.U,[PA,QA],null)],null),new $APP.S(null,3,5,$APP.U,[$APP.yn,NA,new $APP.S(null,2,5,$APP.U,[PA,QA],null)],null),new $APP.S(null,3,5,$APP.U,[$APP.Ym,NA,new $APP.S(null,
2,5,$APP.U,[PA,QA],null)],null),new $APP.S(null,3,5,$APP.U,[$APP.Zm,NA,new $APP.S(null,2,5,$APP.U,[PA,QA],null)],null),new $APP.S(null,2,5,$APP.U,[$APP.Cn,$APP.Cn],null),new $APP.S(null,1,5,$APP.U,[new $APP.S(null,3,5,$APP.U,[OA,MA,$APP.yn],null)],null)],null)],null));TA.l($APP.K(["init hsql/artifacts",$APP.bh($APP.K([b]))]));a.exec($APP.Ql(b));TA.l($APP.K(["init hsql/subs",$APP.bh($APP.K([c]))]));a.exec($APP.Ql(c));return null},YA=function(a,b){var c=HA(new $APP.q(null,2,[VA,"artifacts",WA,new $APP.S(null,
1,5,$APP.U,[$APP.vg(b,new $APP.S(null,4,5,$APP.U,[$APP.zi,$APP.Dm,$APP.Km,$APP.qn],null))],null)],null));TA.l($APP.K(["submit-to-db.art/insert",$APP.bh($APP.K([c]))]));a.exec($APP.Ql(c),{rowMode:"object"});var d=HA(new $APP.q(null,3,[$APP.Qm,MA,ey,"artifacts",jz,$APP.V.i(new $APP.S(null,1,5,$APP.U,[XA],null),cx(function(f){var g=$APP.O.h(b,f);return $APP.r(g)?new $APP.S(null,3,5,$APP.U,[oA,f,g],null):null}),new $APP.S(null,4,5,$APP.U,[$APP.zi,$APP.Dm,$APP.Km,$APP.qn],null))],null));TA.l($APP.K(["submit-to-db.art/query",
$APP.bh($APP.K([d]))]));var e=a.exec($APP.Ql(d),{rowMode:"object"})[0].sf;TA.l($APP.K(["submit-to-db.art/idx",e]));d=HA(new $APP.q(null,2,[VA,"subtitles",WA,jx(function(f,g){var k=$APP.M(g,0,null),l=$APP.M(g,1,null);g=$APP.M(g,2,null);return new $APP.q(null,5,[MA,e,$APP.yn,f,$APP.Ym,k,$APP.Zm,l,$APP.Cn,g],null)},$APP.an.g(b))],null));TA.l($APP.K(["submit-to-db.subs/insert",$APP.bh($APP.K([c]))]));a.exec($APP.Ql(d),{rowMode:"object"});return console.log(e)},$A=function(a,b){var c=HA(new $APP.q(null,
3,[$APP.Qm,ZA,ey,"artifacts",jz,$APP.V.i(new $APP.S(null,1,5,$APP.U,[XA],null),cx(function(d){var e=$APP.O.h(b,d);return $APP.r(e)?new $APP.S(null,3,5,$APP.U,[oA,d,e],null):null}),new $APP.S(null,4,5,$APP.U,[$APP.zi,$APP.Dm,$APP.Km,$APP.qn],null))],null));$APP.zm.l($APP.K(["---sql",c]));a=a.exec($APP.Ql(c),{rowMode:"object"});a=$APP.V.i($APP.Oe,$APP.Q.g(JA),a);TA.l($APP.K(["query",a]));return a},bB=function(a){var b=$APP.zi.g(a);b=b instanceof $APP.P?b.Ma:null;switch(b){case "query/artifacts":return postMessage($APP.bh($APP.K([new $APP.q(null,
2,[$APP.zi,$APP.vn,$APP.Nm,$A($APP.w(aB),$APP.un.g(a))],null)])));case "query/subtitles":return b=postMessage,a=$APP.w(aB).exec([["select * from subtitles as S inner join artifacts as A on S.artidx \x3d A.artidx where text like '%",$APP.t.g($APP.hn.g(a)),"%'"].join("")],{rowMode:"object"}),a=$APP.V.i($APP.Oe,$APP.Q.g(JA),a),TA.l($APP.K(["query",a])),b($APP.bh($APP.K([new $APP.q(null,2,[$APP.zi,$APP.Fm,$APP.Nm,a],null)])));case "nuke":return a=$APP.w(aB).exec(["drop table artifacts; drop table subtitles"],
{rowMode:"object"}),TA.l($APP.K(["nuke-db"])),console.log(a);case "init":return UA($APP.w(aB));case "populate":return a=$APP.w(aB),b=HA(new $APP.q(null,2,[VA,"artifacts",WA,new $APP.S(null,1,5,$APP.U,[new $APP.q(null,4,[$APP.zi,"movie",$APP.Dm,"1990",$APP.Km,"A movie",$APP.qn,"someone"],null)],null)],null)),TA.l($APP.K(["populate-db",$APP.bh($APP.K([b]))])),a=a.exec($APP.Ql(b),{rowMode:"object"}),console.log(a);case "submit":return YA($APP.w(aB),$APP.un.g(a));case "exec":return b=$APP.w(aB),a=$APP.ln.g(a),
a=b.exec([a],{rowMode:"object"}),console.log(a);default:throw Error(["No matching clause: ",$APP.t.g(b)].join(""));}},bz=function bz(a){switch(arguments.length){case 1:return bz.g(arguments[0]);case 2:return bz.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return bz.l(arguments[0],arguments[1],new $APP.jc(c.slice(2),0,null))}};bz.g=function(a){return a};bz.h=function(a,b){return a>b?a:b};
bz.l=function(a,b,c){return $APP.Ia(bz,a>b?a:b,c)};bz.G=function(a){var b=$APP.D(a),c=$APP.F(a);a=$APP.D(c);c=$APP.F(c);return this.l(b,a,c)};bz.H=2;
var cB=new $APP.P(null,"left","left",-399115937),dB=new $APP.y("honey.sql","format-values","honey.sql/format-values",-1036296980,null),eB=new $APP.P(null,"right-join","right-join",-56349359),fy=new $APP.y(null,"from","from",-839142725,null),fB=new $APP.y(null,"data","data",1407862150,null),gB=new $APP.P(null,"right","right",-452581833),hB=new $APP.P(null,"not\x3d","not\x3d",-173995323),XA=new $APP.P(null,"and","and",-971899817),iB=new $APP.P(null,"add-column","add-column",141289410),jB=new $APP.P(null,
"row","row",-570139521),kB=new $APP.y("honey.sql","format-selects-on","honey.sql/format-selects-on",-1915340976,null),lB=new $APP.y(null,"format-alter-table","format-alter-table",1715578287,null),Xx=new $APP.P(null,"drop-ns","drop-ns",-1721308319),ey=new $APP.P(null,"from","from",1815293044),mB=new $APP.P(null,"rename-to","rename-to",610483329),yz=new $APP.P(null,"data","data",-232669377),nB=new $APP.P(null,"left-join","left-join",-672831855),MA=new $APP.P(null,"artidx","artidx",729627957),oB=new $APP.P(null,
"entity","entity",-450970276),pB=new $APP.y("honey.sql","format-add-item","honey.sql/format-add-item",-481215333,null),qB=new $APP.y(null,"function-1-opt","function-1-opt",-1283255102,null),rB=new $APP.y("honey.sql","format-with-data","honey.sql/format-with-data",231865992,null),sB=new $APP.P(null,"partition-by","partition-by",1324497520),tB=new $APP.P(null,"index","index",-1531685915),uB=new $APP.y("honey.sql","format-selects","honey.sql/format-selects",-1805335445,null),tz=new $APP.P(null,"create",
"create",-1301499256),vB=new $APP.y("honey.sql","format-join-by","honey.sql/format-join-by",-957187997,null),gz=new $APP.P(null,"dialect","dialect",-1374251073),ux=new $APP.P(null,"failure","failure",720415879),oy=new $APP.P(null,"top","top",-1856271961),wB=new $APP.y("honey.sql","format-on-set-op","honey.sql/format-on-set-op",-1702673170,null),xB=new $APP.y(null,"table","table",1075588491,null),yB=new $APP.y(null,"format-on-conflict","format-on-conflict",-1736149702,null),zB=new $APP.P(null,"fetch-next",
"fetch-next",-1540729894),gy=new $APP.y(null,"window","window",-1929916235,null),uA=new $APP.P(null,"inline","inline",1399884222),ay=new $APP.y(null,"select","select",-1506602266,null),AB=new $APP.y("honey.sql","format-select-top","honey.sql/format-select-top",-1063564218,null),BB=new $APP.P(null,"on-conflict","on-conflict",1595391642),CB=new $APP.P(null,"drop-extension","drop-extension",-1677190153),DB=new $APP.P(null,"select-distinct-top","select-distinct-top",781185536),wz=new $APP.P(null,"with",
"with",-1536296876),gA=new $APP.P(null,"end","end",-268185958),EB=new $APP.y("honey.sql","format-table-columns","honey.sql/format-table-columns",-1905715432,null),FB=new $APP.y(null,"format-drop-items","format-drop-items",-390921529,null),Bz=new $APP.y(null,"if-exists","if-exists",-323575506,null),GB=new $APP.P(null,"truncate","truncate",-1327322939),HB=new $APP.y(null,"params","params",-1943919534,null),IB=new $APP.P(null,"create-table-as","create-table-as",209299497),JB=new $APP.P(null,"add","add",
235287739),KB=new $APP.P(null,"row-only","row-only",-701331619),Ny=new $APP.P(null,"wait","wait",-260664777),LB=new $APP.y("honey.sql","format-alter-table","honey.sql/format-alter-table",-772015936,null),kz=new $APP.y(null,"where","where",-404264438,null),SA=new $APP.P(null,"composite","composite",-257118970),MB=new $APP.P(null,"intersect","intersect",-2039792392),iz=new $APP.P(null,"fields","fields",-1932066230),Cx=new $APP.P("honey.sql","wrapper","honey.sql/wrapper",465758343),NB=new $APP.P(null,
"update","update",1045576396),Iz=new $APP.y(null,"xs","xs",-2004992428,null),OB=new $APP.y("honey.sql","format-selector","honey.sql/format-selector",-2093502057,null),PB=new $APP.P(null,"with-recursive","with-recursive",-331779146),QB=new $APP.P(null,"cross-join","cross-join",-1043003533),mx=new $APP.y("honey.sql.protocols","sqlize","honey.sql.protocols/sqlize",160108832,null),RB=new $APP.P(null,"array","array",-2080713842),SB=new $APP.P(null,"foreign-key","foreign-key",124300407),TB=new $APP.y(null,
"format-lock-strength","format-lock-strength",-476935778,null),nz=new $APP.P(null,"expr","expr",745722291),UB=new $APP.P(null,"raw","raw",1604651272),VB=new $APP.P(null,"alter-table","alter-table",1000463814),Kz=new $APP.y(null,"if-not-exists","if-not-exists",-1915428844,null),WB=new $APP.P(null,"rows","rows",850049680),XB=new $APP.P(null,"drop-table","drop-table",371446895),YB=new $APP.y("honey.sql","format-set-exprs","honey.sql/format-set-exprs",-1348278137,null),NA=new $APP.P(null,"integer","integer",
-604721710),rz=new $APP.P(null,"if-not-exists","if-not-exists",739006925),ZB=new $APP.y(null,"format-insert","format-insert",-1993090639,null),$B=new $APP.P(null,"between","between",1131099276),Kx=new $APP.P(null,"nested","nested",18943849),Gz=new $APP.y("honey.sql","format-single-column","honey.sql/format-single-column",348585542,null),Hz=new $APP.y(null,"format-single-column","format-single-column",1632648491,null),aC=new $APP.P(null,"filter","filter",-948537934),bC=new $APP.y(null,"format-join",
"format-join",-242897439,null),cC=new $APP.P(null,"rows-only","rows-only",1193970146),vA=new $APP.P(null,"cache","cache",-1237023054),dC=new $APP.P(null,"full","full",436801220),eC=new $APP.P(null,"create-extension","create-extension",853957283),fC=new $APP.P(null,"fetch","fetch",-1081994244),gC=new $APP.P(null,"materialized-view","materialized-view",-1218575593),hC=new $APP.P("bigquery","array","bigquery/array",1718523718),iC=new $APP.P(null,"returning","returning",-387623629),jC=new $APP.P(null,
"nest","nest",-314993663),kC=new $APP.P(null,"outer","outer",-375185956),lC=new $APP.y("honey.sql","format-lock-strength","honey.sql/format-lock-strength",1596503099,null),mC=new $APP.P(null,"param","param",2013631823),bA=new $APP.P(null,"case-expr","case-expr",-1006930349),Ix=new $APP.P(null,"aliased","aliased",-125439273),Xy=new $APP.y(null,"aliased","aliased",1515092254,null),nC=new $APP.y(null,"format-on-set-op","format-on-set-op",-700808827,null),Sy=new $APP.P(null,"fixed-arity","fixed-arity",
1586445869),Uy=new $APP.P(null,"method-params","method-params",-980792179),fz=new $APP.P(null,"mysql","mysql",-1431590210),oC=new $APP.y("honey.sql","format-insert","honey.sql/format-insert",-710305188,null),pC=new $APP.P(null,"do-nothing","do-nothing",1030476282),Sx=new $APP.P(null,"unexpected","unexpected",-1137752424),Ry=new $APP.P(null,"variadic?","variadic?",584179762),zA=new $APP.P(null,"checking","checking",1748720818),qC=new $APP.y(null,"format-select-top","format-select-top",872583137,null),
rC=new $APP.P(null,"except","except",1116893347),sC=new $APP.y(null,"format-values","format-values",245403713,null),tC=new $APP.y(null,"format-set-exprs","format-set-exprs",2077764458,null),RA=new $APP.P(null,"unique","unique",329397282),Wz=new $APP.P(null,"strict","strict",-665564191),Ly=new $APP.P(null,"skip-locked","skip-locked",-202896094),pA=new $APP.P(null,"not-in","not-in",1005390648),uC=new $APP.P(null,"drop-column","drop-column",-1898063225),vC=new $APP.P(null,"view","view",1247994814),wC=
new $APP.y("honey.sql","case-clauses","honey.sql/case-clauses",-228279509,null),xC=new $APP.P(null,"rename-column","rename-column",737487070),yC=new $APP.P(null,"union","union",2142937499),zC=new $APP.P(null,"oracle","oracle",-2085139604),AC=new $APP.y("honey.sql","format-group-by","honey.sql/format-group-by",508553260,null),BC=new $APP.P(null,"regexp","regexp",-541372782),CC=new $APP.y(null,"format-selects-on","format-selects-on",1178618827,null),DC=new $APP.y(null,"format-do-update-set","format-do-update-set",
-1807098341,null),My=new $APP.P(null,"nowait","nowait",-1298090166),EC=new $APP.y(null,"case-clauses","case-clauses",233734030,null),FC=new $APP.P(null,"on-duplicate-key-update","on-duplicate-key-update",596044873),GC=new $APP.P(null,"ansi","ansi",1415977390),HC=new $APP.y("honey.sql","format-on-conflict","honey.sql/format-on-conflict",1697823191,null),IC=new $APP.P(null,"cross","cross",194557789),DA=new $APP.P(null,"quoted","quoted",2117344952),JC=new $APP.y("honey.sql","function-0","honey.sql/function-0",
1871273967,null),dA=new $APP.P(null,"when","when",-576417306),KC=new $APP.y("honey.sql","function-1","honey.sql/function-1",-375233619,null),LC=new $APP.P(null,"cast","cast",-1761029143),MC=new $APP.y(null,"function-0","function-0",-617407678,null),NC=new $APP.y(null,"function-1","function-1",890872902,null),fA=new $APP.P(null,"case","case",1143702196),Ay=new $APP.P(null,"inner-join","inner-join",659431740),OC=new $APP.P(null,"modify-column","modify-column",-614135147),PC=new $APP.P(null,"having",
"having",-399543166),QC=new $APP.P(null,"drop-materialized-view","drop-materialized-view",-1779110488),Wx=new $APP.P(null,"exprs","exprs",1795829094),RC=new $APP.y("honey.sql","format-rename-item","honey.sql/format-rename-item",853110413,null),SC=new $APP.y(null,"format-group-by","format-group-by",1120249041,null),LA=new $APP.P(null,"with-columns","with-columns",-1220776498),TC=new $APP.y("honey.sql","format-select-into","honey.sql/format-select-into",-75466708,null),nx=new $APP.P("cljs.analyzer",
"no-resolve","cljs.analyzer/no-resolve",-1872351017),UC=new $APP.y("honey.sql","format-order-by","honey.sql/format-order-by",995782973,null),VC=new $APP.P(null,"select-top","select-top",-1243842074),WC=new $APP.y(null,"format-selects","format-selects",1626536724,null),AA=new $APP.P(null,"clause-order-fn","clause-order-fn",-2005456179),XC=new $APP.P(null,"fetch-first","fetch-first",-2144229787),YC=new $APP.P(null,"lateral","lateral",2094286431),my=new $APP.P(null,"with-ties","with-ties",-1030545914),
ZC=new $APP.y(null,"format-join-by","format-join-by",289946392,null),$C=new $APP.P(null,"\x26\x26","\x26\x26",1323453035),Ty=new $APP.P(null,"max-fixed-arity","max-fixed-arity",-690205543),sA=new $APP.P(null,"valid-dialects","valid-dialects",-1269252169),aD=new $APP.P(null,"references","references",882562509),Yy=new $APP.y(null,"drop-ns","drop-ns",-80776792,null),bD=new $APP.y(null,"format-selector","format-selector",1319204090,null),Yx=new $APP.P(null,"columns","columns",1998437288),ky=new $APP.P(null,
"distinct-on","distinct-on",341946250),cD=new $APP.P(null,"alter-column","alter-column",-254828732),Gx=new $APP.P(null,"selectable","selectable",370587038),dD=new $APP.P(null,"drop-index","drop-index",-843154439),Ax=new $APP.P(null,"params","params",710516235),eD=new $APP.P(null,"group-by","group-by",-379139802),az=new $APP.y(null,"default","default",-347290801,null),fD=new $APP.P(null,"quote","quote",-262615245),gD=new $APP.P(null,"delete","delete",-1768633620),hD=new $APP.P(null,"interval","interval",
1708495417),iD=new $APP.P(null,"!\x3d","!\x3d",-1841737356),jD=new $APP.y("honey.sql","format-do-update-set","honey.sql/format-do-update-set",566436710,null),OA=new $APP.P(null,"primary-key","primary-key",1422512605),kD=new $APP.P(null,"materialized","materialized",-1815568995),Zy=new $APP.P(null,"arglists-meta","arglists-meta",1944829838),Az=new $APP.P(null,"if-exists","if-exists",-1964107033),lD=new $APP.P(null,"or","or",235744169),mD=new $APP.P(null,"select-distinct-on","select-distinct-on",1224000227),
nD=new $APP.P(null,"inner","inner",-1383171215),oD=new $APP.y(null,"format-add-item","format-add-item",-1344569474,null),Oy=new $APP.y("honey.sql","format-entity","honey.sql/format-entity",-1824420277,null),pD=new $APP.P(null,"not-materialized","not-materialized",-390756108),qD=new $APP.P(null,"over","over",192553051),jz=new $APP.P(null,"where","where",-2044795965),rD=new $APP.P(null,"disallowed","disallowed",544208344),sD=new $APP.y("honey.sql","format-on-expr","honey.sql/format-on-expr",-1077648278,
null),xz=new $APP.P(null,"no","no",-390373634),dy=new $APP.y(null,"select-distinct","select-distinct",1227895413,null),tD=new $APP.P(null,"create-materialized-view","create-materialized-view",-1173241),VA=new $APP.P(null,"insert-into","insert-into",382212789),uD=new $APP.P(null,"for","for",-1323786319),vD=new $APP.P(null,"add-index","add-index",376820708),wy=new $APP.y(null,"format-entity-alias","format-entity-alias",457072549,null),wD=new $APP.P(null,"escape","escape",-991601952),QA=new $APP.P(null,
"null","null",-180137709),Rx=new $APP.P(null,"alias","alias",-2039751630),xD=new $APP.P("bigquery","struct","bigquery/struct",-596080428),cA=new $APP.y(null,"else","else",132154381,null),Qy=new $APP.y(null,"format-entity","format-entity",618285344,null),yD=new $APP.P(null,"sqlserver","sqlserver",222509918),zD=new $APP.P(null,"bulk-collect-into","bulk-collect-into",1601778032),AD=new $APP.P(null,"full-join","full-join",1305476385),zy=new $APP.P(null,"join","join",-758861890),BD=new $APP.P(null,"lock",
"lock",-488188066),CD=new $APP.P(null,"constraint","constraint",1725147424),hy=new $APP.y(null,"delete-from","delete-from",-1983671803,null),Wy=new $APP.P(null,"keys","keys",1068423698),DD=new $APP.P(null,"with-data","with-data",-1106621804),ED=new $APP.y(null,"format-select-into","format-select-into",253379723,null),FD=new $APP.P(null,"create-view","create-view",-485638509),ny=new $APP.P(null,"percent","percent",2031453817),GD=new $APP.y("honey.sql","format-join","honey.sql/format-join",1142939916,
null),Vy=new $APP.y(null,"e","e",-1273166571,null),HD=new $APP.P(null,"rename-table","rename-table",-651328682),xy=new $APP.y(null,"x","x",-555367584,null),oA=new $APP.P(null,"\x3d","\x3d",1152933628),ID=new $APP.P(null,"table","table",-564943036),JD=new $APP.P(null,"/","/",1282502798),KD=new $APP.y("honey.sql","format-columns","honey.sql/format-columns",-981158916,null),LD=new $APP.y(null,"format-rename-item","format-rename-item",1197681200,null),dz=new $APP.P(null,"first","first",-644103046),By=
new $APP.P(null,"using","using",1948623036),MD=new $APP.P(null,"+","+",1913524883),ZA=new $APP.P(null,"*","*",-1294732318),ND=new $APP.P(null,"drop-view","drop-view",1167937644),OD=new $APP.y(null,"y","y",-117328249,null),PD=new $APP.y(null,"format-order-by","format-order-by",-154127200,null),Rz=new $APP.P(null,"pretty","pretty",-1916372486),QD=new $APP.P(null,"order-by","order-by",1527318070),RD=new $APP.y("honey.sql","function-1-opt","honey.sql/function-1-opt",1209651237,null),uy=new $APP.y("honey.sql",
"format-entity-alias","honey.sql/format-entity-alias",-793484786,null),SD=new $APP.y(null,"format-on-expr","format-on-expr",-211932223,null),WA=new $APP.P(null,"values","values",372645556),TD=new $APP.P(null,"on-constraint","on-constraint",1484874675),UD=new $APP.P(null,"join-by","join-by",1125837996),VD=new $APP.P(null,"extension","extension",1453374065),eA=new $APP.P(null,"then","then",460598070),WD=new $APP.P(null,"lift","lift",903632035),XD=new $APP.P(null,"union-all","union-all",672741919),YD=
new $APP.y(null,"clauses","clauses",-1199594528,null),ZD=new $APP.y(null,"format-table-columns","format-table-columns",-218935107,null),$D=new $APP.P(null,"within-group","within-group",-1794793927),vy=new $APP.y(null,"honey.sql","honey.sql",335271223,null),Dy=new $APP.P(null,"clauses","clauses",1454841241),aE=new $APP.P(null,"replace-into","replace-into",139321349),bE=new $APP.y(null,"format-with-data","format-with-data",-1186217417,null),Ox=new $APP.P(null,"clause","clause",1479668060),KA=new $APP.P(null,
"create-table","create-table",1297148194),PA=new $APP.P(null,"not","not",-595976884),cE=new $APP.y("honey.sql","format-drop-items","honey.sql/format-drop-items",-1127399848,null),iy=new $APP.P(null,"delete-from","delete-from",670763966),Py=new $APP.P(null,"top-fn","top-fn",-2056129173),by=new $APP.P(null,"select-distinct","select-distinct",-412636114),dE=new $APP.y(null,"format-columns","format-columns",-1878102175,null),eE=new $APP.P(null,"outer-join","outer-join",1845838048),GA=new $APP.P(null,
"values-default-columns","values-default-columns",1352539997),fE=new $APP.P(null,"refresh-materialized-view","refresh-materialized-view",-121074453),Jy=new $APP.P(null,"asc","asc",356854569),FA=new $APP.P(null,"quoted-snake","quoted-snake",-1093133358),gE=new $APP.P(null,"||","||",-207700737),nA=new $APP.P(null,"\x3c\x3e","\x3c\x3e",1280186386),cy=new $APP.P(null,"window","window",724519534),Px=new $APP.P(null,"arg","arg",-1747261837),hE=new $APP.P(null,"except-all","except-all",1562150045),qy=new $APP.P(null,
"limit","limit",-1355822363),px=new $APP.P(null,"known-clauses","known-clauses",-1092829159),iE=new $APP.P(null,"do-update-set","do-update-set",-2028298967),uz=new $APP.P(null,"refresh","refresh",1947415525);var jE=$APP.bf([VB,iB,uC,cD,OC,xC,vD,dD,HD,KA,IB,LA,FD,tD,eC,XB,ND,QC,CB,fE,UB,jC,wz,PB,MB,yC,XD,rC,hE,ID,$APP.Qm,by,mD,VC,DB,$APP.Kn,zD,VA,NB,gD,iy,GB,Yx,$APP.yi,ey,By,UD,zy,nB,eB,Ay,eE,AD,QB,jz,eD,PC,cy,sB,QD,qy,$APP.Jm,fC,uD,BD,WA,BB,TD,pC,iE,FC,iC,DD],!0),rA=$APP.Ae($APP.td(function(a,b,c){return $APP.ug.i(a,b,$APP.ug.i(c,gz,b))},$APP.ne,new $APP.q(null,4,[GC,new $APP.q(null,1,[fD,function(a){return rx('"',a,'"')}],null),yD,new $APP.q(null,1,[fD,function(a){return rx("[",a,"]")}],null),fz,new $APP.q(null,
2,[fD,function(a){return rx("`",a,"`")},AA,function(a){IA.i?IA.i(aE,VA,VA):IA.call(null,aE,VA,VA);return qx(a,$APP.yi,jz)}],null),zC,new $APP.q(null,2,[fD,function(a){return rx('"',a,'"')},$APP.sn,!1],null)],null))),yA=$APP.Ae(GC.g($APP.w(rA))),EA=$APP.Ae(null),Hx=null,Tz=jE,wA=null,xA=null,Ex=null,zx=null,cz=null,$x=$APP.Nn,sx=null,Vz=null,wx=function wx(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return wx.l(arguments[0],1<c.length?new $APP.jc(c.slice(1),
0,null):null)};
wx.l=function(a,b){b=$APP.M(b,0,null);b=$APP.oe(b);var c=$APP.O.h(b,Ix),d=$APP.O.h(b,Xx);b=$APP.r(function(){var l=wA;return $APP.r(l)?l:"string"===typeof a}())?$APP.r(xA)?vx:$APP.Cg:vx;var e=b.g?b.g(a):b.call(null,a),f=fD.h(Hx,$APP.ud),g=$APP.r(function(){var l=wA;return $APP.r(l)?l:"string"===typeof a}())?f:null==wA?function(l){return $APP.r($APP.Mg(/^[A-Za-z0-9_]+$/,l))?l:f.g?f.g(l):f.call(null,l)}:$APP.ud;b=function(){if($APP.r($APP.r(d)?d:"string"===typeof a))var l=null;else try{var m=$APP.Kd(a);
l=null==m?null:$APP.Xh(m,"-","_")}catch(n){throw l=n,$APP.Th(["expected symbol, found: ",$APP.t.g($APP.Ea(a))].join(""),new $APP.q(null,2,[$APP.Cj,a,ux,$APP.t.g(l)],null));}return $APP.r(l)?new $APP.S(null,2,5,$APP.U,[l,e],null):$APP.r(c)?new $APP.S(null,1,5,$APP.U,[e],null):$APP.$h(e,/\./)}();b=$APP.Yh(".",$APP.Q.h(function(l){return $APP.pe("*",l)?g.g?g.g(l):g.call(null,l):l},b));var k=/;/;if(!$APP.r(!1)&&$APP.r($APP.Mg(k,b)))throw $APP.Th(["suspicious character found in entity: ",b].join(""),new $APP.q(null,
1,[rD,k],null));return b};wx.H=1;wx.G=function(a){var b=$APP.D(a);a=$APP.F(a);return this.l(b,a)};ox["null"]=function(){return"NULL"};ox.string=function(a){return["'",$APP.Xh(a,"'","''"),"'"].join("")};$APP.P.prototype.Xc=function(){return xx(this)};$APP.y.prototype.Xc=function(){return xx(this)};$APP.S.prototype.Xc=function(){return["[",$APP.Yh(", ",$APP.Q.h(ox,this)),"]"].join("")};ox._=function(a){return $APP.t.g(a)};
var Ey=new $APP.q(null,7,[zy,Ay,cB,nB,gB,eB,nD,Ay,kC,eE,dC,AD,IC,QB],null),Fy=$APP.Ag($APP.sg(Ey)),kE=function kE(a,b){if($APP.Uc(b)){var d=gx($APP.Ld,b),e=$APP.G(d),f=$APP.A($APP.De(e,b)),g=$APP.D(f),k=$APP.F(f);if($APP.r(function(){var l=$APP.A(k);return l?l:$APP.r(g)?!$APP.Vc(g):g}()))throw $APP.Th("unsupported :on-conflict format",new $APP.q(null,1,[Ox,b],null));b=$APP.r(g)?Lx.g?Lx.g(g):Lx.call(null,g):null;f=$APP.A(b);b=$APP.D(f);f=$APP.F(f);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[xx(a),
0<e?[" (",$APP.Yh(", ",$APP.Q.h(new $APP.z(function(){return wx},Oy,$APP.kg([$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,Py,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),Qy,"honey/sql.cljc",20,new $APP.q(null,6,[Ry,!0,Sy,1,Ty,1,Uy,new $APP.S(null,1,5,$APP.U,[$APP.W(Vy,new $APP.S(null,1,5,$APP.U,[new $APP.q(null,1,[Wy,new $APP.S(null,2,5,$APP.U,[Xy,Yy],null)],null)],null))],null),$APP.Rm,$APP.W(new $APP.S(null,3,5,$APP.U,[Vy,$APP.Dn,new $APP.S(null,1,5,$APP.U,[new $APP.q(null,1,[Wy,new $APP.S(null,2,5,$APP.U,[Xy,Yy],null)],null)],null)],null)),Zy,$APP.W(null)],null),1,209,209,$APP.W(new $APP.S(null,3,5,$APP.U,[Vy,$APP.Dn,new $APP.S(null,1,5,$APP.U,[new $APP.q(null,
1,[Wy,new $APP.S(null,2,5,$APP.U,[Xy,Yy],null)],null)],null)],null)),"Given a simple SQL entity (a keyword or symbol -- or string),\n  return the equivalent SQL fragment (as a string -- no parameters).\n\n  Handles quoting, splitting at / or ., replacing - with _ etc.",$APP.r(wx)?wx.F:null])),d)),")"].join(""):null,$APP.r(b)?[" ",$APP.t.g(b)].join(""):null].join("")],null),f)}d=new $APP.S(null,1,5,$APP.U,[b],null);return kE.h?kE.h(a,d):kE.call(null,a,d)},Ez=$APP.Ae(!1),BA=$APP.Ae(jE),CA=$APP.Ae(jE),
Sz=$APP.Ae($APP.kg([eE,DB,jC,AD,PC,KA,iB,rC,$APP.Kn,eC,mD,jz,cD,ID,vD,GB,qy,eD,VB,VC,$APP.Jm,tD,uC,UB,QC,Yx,IB,FC,iE,fE,ND,UD,NB,gD,by,LA,cy,XB,zD,sB,eB,nB,uD,iC,FD,QB,TD,wz,ey,DD,WA,OC,VA,QD,HD,PB,CB,MB,dD,$APP.yi,pC,BB,yC,By,Ay,fC,hE,xC,BD,iy,zy,$APP.Qm,XD],[new $APP.z(function(){return Cy},GD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bC,"honey/sql.cljc",19,1,601,601,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,YD],null)),null,$APP.r(Cy)?Cy.F:null])),new $APP.z(function(){return py},AB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),qC,"honey/sql.cljc",25,1,496,496,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(py)?py.F:null])),function(a,b){a=new $APP.q(null,1,[Kx,!0],null);b=Lx.h?Lx.h(b,a):Lx.call(null,b,a);a=$APP.A(b);b=$APP.D(a);a=$APP.F(a);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[b],null),a)},new $APP.z(function(){return Cy},GD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bC,"honey/sql.cljc",19,1,601,601,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,YD],null)),null,$APP.r(Cy)?Cy.F:null])),new $APP.z(function(){return Hy},sD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),SD,"honey/sql.cljc",22,1,670,670,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Vy],null)),null,$APP.r(Hy)?Hy.F:null])),function(a,b){return vz(tz,ID,b,null)},new $APP.z(function(){return Lz},pB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),oD,"honey/sql.cljc",23,1,955,955,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,$APP.Em],null)),null,$APP.r(Lz)?Lz.F:null])),new $APP.z(function(){return Ux},wB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),nC,"honey/sql.cljc",24,1,434,434,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Ux)?Ux.F:null])),new $APP.z(function(){return ry},TC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),ED,"honey/sql.cljc",26,1,524,524,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(ry)?ry.F:null])),function(a,b){return vz(tz,VD,b,null)},new $APP.z(function(){return ly},kB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),CC,"honey/sql.cljc",25,1,485,485,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.En,Iz],null)),null,$APP.r(ly)?ly.F:null])),new $APP.z(function(){return Hy},sD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),SD,"honey/sql.cljc",22,1,670,670,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Vy],null)),null,$APP.r(Hy)?Hy.F:null])),function(a,b){return Lz($APP.H.h(fz,gz.g(Hx))?OC:a,b)},new $APP.z(function(){return ty},OB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bD,"honey/sql.cljc",23,1,557,557,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(ty)?ty.F:null])),function(a,b){return Hy(JB,b)},new $APP.z(function(){return ty},OB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bD,"honey/sql.cljc",23,1,557,557,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(ty)?ty.F:null])),new $APP.z(function(){return Hy},sD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),SD,"honey/sql.cljc",22,1,670,670,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Vy],null)),null,$APP.r(Hy)?Hy.F:null])),new $APP.z(function(){return Iy},AC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),SC,"honey/sql.cljc",23,1,676,676,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Iy)?Iy.F:null])),new $APP.z(function(){return pz},LB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),lB,"honey/sql.cljc",26,1,855,855,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,xy],null)),null,$APP.r(pz)?pz.F:null])),new $APP.z(function(){return py},AB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),qC,"honey/sql.cljc",25,1,496,496,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(py)?py.F:null])),function(a,b){if(tx(fC)||$APP.H.h(yD,gz.g(Hx))){a=Hy($APP.Jm,b);var c=$APP.A(a);a=$APP.D(c);c=$APP.F(c);b="number"===typeof b&&1===b?jB:WB;return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[$APP.t.g(a)," ",xx(b)].join("")],null),c)}return Hy($APP.Jm,b)},function(a,b){return vz(tz,gC,b,$APP.sn)},new $APP.z(function(){return Dz},cE,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,
$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),FB,"honey/sql.cljc",25,1,934,934,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,HB],null)),null,$APP.r(Dz)?Dz.F:null])),function(a,b){return Nz(b)},new $APP.z(function(){return Dz},cE,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),FB,"honey/sql.cljc",25,1,934,934,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,HB],null)),null,$APP.r(Dz)?Dz.F:null])),new $APP.z(function(){return Zx},KD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),dE,"honey/sql.cljc",22,1,462,462,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Zx)?Zx.F:null])),function(a,b){return vz(tz,ID,b,$APP.sn)},new $APP.z(function(){return lz},jD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),DC,"honey/sql.cljc",28,1,816,816,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,xy],null)),null,$APP.r(lz)?lz.F:null])),new $APP.z(function(){return lz},jD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),DC,"honey/sql.cljc",28,1,816,816,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,xy],null)),null,$APP.r(lz)?lz.F:null])),function(a,b){return vz(uz,gC,b,null)},new $APP.z(function(){return Dz},cE,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),FB,"honey/sql.cljc",25,1,934,934,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,HB],null)),null,$APP.r(Dz)?Dz.F:null])),new $APP.z(function(){return Gy},vB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),ZC,"honey/sql.cljc",22,1,641,641,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.En,YD],null)),"Clauses should be a sequence of join types followed\n  by their table and condition, or a sequence of join\n  clauses, so that you can construct a series of joins\n  in a specific order.",$APP.r(Gy)?Gy.F:null])),Oz(new $APP.z(function(){return ty},OB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bD,"honey/sql.cljc",23,1,557,557,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(ty)?ty.F:null]))),Oz(new $APP.z(function(){return jy},uB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),WC,"honey/sql.cljc",22,1,477,477,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(jy)?jy.F:null]))),new $APP.z(function(){return jy},uB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),WC,"honey/sql.cljc",22,1,477,477,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(jy)?jy.F:null])),new $APP.z(function(){return Jz},EB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),ZD,"honey/sql.cljc",28,1,950,950,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.En,Iz],null)),null,$APP.r(Jz)?Jz.F:null])),new $APP.z(function(){return ty},OB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bD,"honey/sql.cljc",23,1,557,557,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(ty)?ty.F:null])),new $APP.z(function(){return Dz},cE,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),FB,"honey/sql.cljc",25,1,934,934,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,HB],null)),null,$APP.r(Dz)?Dz.F:null])),new $APP.z(function(){return ry},TC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),ED,"honey/sql.cljc",26,1,524,524,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(ry)?ry.F:null])),new $APP.z(function(){return jy},uB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),WC,"honey/sql.cljc",22,1,477,477,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(jy)?jy.F:null])),new $APP.z(function(){return Cy},GD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bC,"honey/sql.cljc",19,1,601,601,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,YD],null)),null,$APP.r(Cy)?Cy.F:null])),new $APP.z(function(){return Cy},GD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bC,"honey/sql.cljc",19,1,601,601,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,YD],null)),null,$APP.r(Cy)?Cy.F:null])),new $APP.z(function(){return $y},lC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),TB,"honey/sql.cljc",28,1,690,690,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r($y)?$y.F:null])),new $APP.z(function(){return jy},uB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),WC,"honey/sql.cljc",22,1,477,477,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(jy)?jy.F:null])),function(a,b){return vz(tz,vC,b,$APP.sn)},new $APP.z(function(){return jy},uB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),WC,"honey/sql.cljc",22,1,477,477,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(jy)?jy.F:null])),new $APP.z(function(){return ty},OB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bD,"honey/sql.cljc",23,1,557,557,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(ty)?ty.F:null])),function(){function a(b){$APP.M(b,0,null);$APP.M(b,1,null);b=$APP.M(b,2,null);return $APP.r($APP.H.h?$APP.H.h(kD,b):$APP.H.call(null,kD,b))?"AS MATERIALIZED":$APP.r($APP.H.h?$APP.H.h(pD,b):$APP.H.call(null,pD,b))?"AS NOT MATERIALIZED":"AS"}return function(b,c){return sy(b,c,a)}}(),new $APP.z(function(){return jy},uB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,
$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),WC,"honey/sql.cljc",22,1,477,477,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(jy)?jy.F:null])),new $APP.z(function(){return zz},rB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bE,"honey/sql.cljc",24,1,912,912,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.En,fB],null)),null,$APP.r(zz)?zz.F:null])),new $APP.z(function(){return ez},dB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),sC,"honey/sql.cljc",21,1,706,706,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(ez)?ez.F:null])),new $APP.z(function(){return Lz},pB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),oD,"honey/sql.cljc",23,1,955,955,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,$APP.Em],null)),null,$APP.r(Lz)?Lz.F:null])),new $APP.z(function(){return yy},oC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),ZB,"honey/sql.cljc",21,1,560,560,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,xB],null)),null,$APP.r(yy)?yy.F:null])),new $APP.z(function(){return Ky},UC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),PD,"honey/sql.cljc",23,1,680,680,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Ky)?Ky.F:null])),function(a,b){return ty(mB,b)},function(){var a=$APP.xe("AS");return function(b,c){return sy(b,c,a)}}(),new $APP.z(function(){return Dz},cE,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),FB,"honey/sql.cljc",25,1,934,934,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,HB],null)),null,$APP.r(Dz)?Dz.F:null])),new $APP.z(function(){return Ux},wB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),nC,"honey/sql.cljc",24,1,434,434,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Ux)?Ux.F:null])),new $APP.z(function(){return ty},OB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bD,"honey/sql.cljc",23,1,557,557,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(ty)?ty.F:null])),new $APP.z(function(){return hz},YB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),tC,"honey/sql.cljc",24,1,785,785,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(hz)?hz.F:null])),function(a){return new $APP.S(null,1,5,$APP.U,[xx(a)],null)},new $APP.z(function(){return kE},HC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),yB,"honey/sql.cljc",26,1,795,795,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,xy],null)),null,$APP.r(kE)?kE.F:null])),new $APP.z(function(){return Ux},wB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),nC,"honey/sql.cljc",24,1,434,434,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Ux)?Ux.F:null])),new $APP.z(function(){return jy},uB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),WC,"honey/sql.cljc",22,1,477,477,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(jy)?jy.F:null])),new $APP.z(function(){return Cy},GD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bC,"honey/sql.cljc",19,1,601,601,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,YD],null)),null,$APP.r(Cy)?Cy.F:null])),function(a,b){var c=tx($APP.Jm)?zB:XC;a="number"===typeof b&&1===b?KB:cC;b=Hy(c,b);c=$APP.A(b);b=$APP.D(c);c=$APP.F(c);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[[$APP.t.g(b)," ",xx(a)].join("")],null),c)},new $APP.z(function(){return Ux},wB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,
"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),nC,"honey/sql.cljc",24,1,434,434,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Ux)?Ux.F:null])),new $APP.z(function(){return Mz},RC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),LD,"honey/sql.cljc",26,1,960,960,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,new $APP.S(null,2,5,$APP.U,[xy,OD],null)],null)),null,$APP.r(Mz)?Mz.F:null])),new $APP.z(function(){return $y},lC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),TB,"honey/sql.cljc",28,1,690,690,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r($y)?$y.F:null])),Oz(new $APP.z(function(){return ty},OB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bD,"honey/sql.cljc",23,1,557,557,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(ty)?ty.F:null]))),new $APP.z(function(){return Cy},GD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),bC,"honey/sql.cljc",19,1,601,601,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,YD],null)),null,$APP.r(Cy)?Cy.F:null])),new $APP.z(function(){return jy},uB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),WC,"honey/sql.cljc",22,1,477,477,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(jy)?jy.F:null])),new $APP.z(function(){return Ux},wB,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),nC,"honey/sql.cljc",24,1,434,434,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Ux)?Ux.F:null]))])),mA=new $APP.q(null,3,[hB,nA,iD,nA,$APP.Xm,BC],null),jA=$APP.Ae($APP.Ed.h($APP.V.i($APP.zg,$APP.Q.g($APP.Wg),$APP.V.h($APP.V.h($APP.V.h(new $APP.xg(null,new $APP.q(null,22,["\x26\x26",null,"!\x3d",null,"\x3c-\x3e",null,"\x3c\x3d",null,"is",null,"like",null,"regex",null,"not-like",null,"similar-to",null,"not\x3d",null,"regexp",null,"or",null,"\x3e\x3d",null,"not-similar-to",
null,"and",null,"mod",null,"\x3c\x3e",null,"not-ilike",null,"is-not",null,"ilike",null,"||",null,"xor",null],null),null),$APP.Q.h($APP.t,"+-*%|\x26^\x3d\x3c\x3e")),$APP.qg(mA)),$APP.sg(mA))),JD)),lA=$APP.Ae(new $APP.xg(null,new $APP.q(null,2,[lD,null,XA,null],null),null)),kA=$APP.Ae(new $APP.xg(null,new $APP.q(null,6,[ZA,null,lD,null,$C,null,MD,null,XA,null,gE,null],null),null)),qA=$APP.Ae($APP.kg([CD,wD,jC,RA,WD,tB,SA,hC,UB,$APP.Kh,LC,$B,PA,aD,RB,mC,$APP.Um,aC,bA,xD,fA,QD,SB,hD,$D,qD,oB,OA,uA,YC],
[new $APP.z(function(){return Zz},KC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),NC,"honey/sql.cljc",18,1,1213,1213,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Zz)?Zz.F:null])),function(a,b){a=$APP.M(b,0,null);var c=$APP.M(b,1,null);b=Z.g?Z.g(a):Z.call(null,a);a=$APP.A(b);b=$APP.D(a);a=$APP.F(a);c=Z.g?Z.g(c):Z.call(null,c);var d=$APP.A(c);c=$APP.D(d);d=$APP.F(d);return $APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[[$APP.t.g(b)," ",xx(wD)," ",$APP.t.g(c)].join("")],null),a),d)},function(a,b){a=$APP.M(b,0,null);a=Z.g?Z.g(a):Z.call(null,a);b=$APP.A(a);
a=$APP.D(b);b=$APP.F(b);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[["(",$APP.t.g(a),")"].join("")],null),b)},new $APP.z(function(){return $z},RD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),qB,"honey/sql.cljc",22,1,1225,1225,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r($z)?$z.F:null])),function(a,b){a=$APP.M(b,0,null);return $APP.r(Ex)?new $APP.S(null,1,5,$APP.U,[ox(a)],null):new $APP.S(null,2,5,$APP.U,["?",$APP.N($APP.xe(a),new $APP.q(null,1,[Cx,function(c){return c.m?c.m():c.call(null)}],null))],null)},new $APP.z(function(){return $z},RD,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,
1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),qB,"honey/sql.cljc",22,1,1225,1225,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r($z)?$z.F:null])),function(a,b){a=$APP.A(b);b=Mx(a);a=$APP.M(b,0,null);b=$APP.M(b,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[["(",$APP.Yh(", ",a),")"].join("")],null),b)},function(a,b){return new $APP.S(null,1,5,$APP.U,[["ARRAY\x3c",$APP.Yh(" ",$APP.Q.h(function(c){return oz(c,"column operation")},b)),"\x3e"].join("")],null)},function(a,b){a=$APP.M(b,0,null);return Nz(a)},new $APP.z(function(){return Zz},
KC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),NC,"honey/sql.cljc",18,1,1213,1213,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Zz)?Zz.F:null])),function(a,b){a=$APP.M(b,0,null);var c=$APP.M(b,1,null);b=Z.g?Z.g(a):Z.call(null,a);a=$APP.A(b);b=$APP.D(a);a=$APP.F(a);c=Z.g?Z.g(c):Z.call(null,c);var d=$APP.A(c);c=$APP.D(d);d=$APP.F(d);return $APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[["CAST(",$APP.t.g(b)," AS ",$APP.t.g(c),")"].join("")],null),a),d)},function(a,b){var c=$APP.M(b,0,null),d=$APP.M(b,1,null),e=$APP.M(b,
2,null);a=function(){var m=new $APP.q(null,1,[Kx,!0],null);return Z.h?Z.h(c,m):Z.call(null,c,m)}();b=$APP.A(a);a=$APP.D(b);b=$APP.F(b);var f=function(){var m=new $APP.q(null,1,[Kx,!0],null);return Z.h?Z.h(d,m):Z.call(null,d,m)}(),g=$APP.A(f);f=$APP.D(g);g=$APP.F(g);var k=function(){var m=new $APP.q(null,1,[Kx,!0],null);return Z.h?Z.h(e,m):Z.call(null,e,m)}(),l=$APP.A(k);k=$APP.D(l);l=$APP.F(l);return $APP.V.h($APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[[$APP.t.g(a)," BETWEEN ",$APP.t.g(f)," AND ",
$APP.t.g(k)].join("")],null),b),g),l)},function(a,b){a=$APP.M(b,0,null);b=new $APP.q(null,1,[Kx,!0],null);a=Z.h?Z.h(a,b):Z.call(null,a,b);b=$APP.A(a);a=$APP.D(b);b=$APP.F(b);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[["NOT ",$APP.t.g(a)].join("")],null),b)},new $APP.z(function(){return Zz},KC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),NC,"honey/sql.cljc",18,1,1213,1213,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Zz)?Zz.F:null])),function(a,b){a=$APP.M(b,0,null);b=Mx(a);a=$APP.M(b,0,null);b=$APP.M(b,1,null);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[["ARRAY[",$APP.Yh(", ",a),"]"].join("")],null),b)},function(a,b){a=$APP.M(b,0,null);return $APP.r(Ex)?new $APP.S(null,1,5,$APP.U,[ox(Bx(a))],null):new $APP.S(null,2,5,$APP.U,["?",Dx(a)],null)},function(a,b){a=$APP.M(b,0,null);b=new $APP.q(null,1,[Kx,!0],
null);a=Z.h?Z.h(a,b):Z.call(null,a,b);b=$APP.A(a);a=$APP.D(b);b=$APP.F(b);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[["DISTINCT ",$APP.t.g(a)].join("")],null),b)},aA,new $APP.z(function(){return hA},wC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),EC,"honey/sql.cljc",20,1,1251,1251,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,YD],null)),"For both :case and :case-expr.",$APP.r(hA)?hA.F:null])),function(a,b){return new $APP.S(null,1,5,$APP.U,[["STRUCT\x3c",$APP.Yh(", ",$APP.Q.h(Fz,b)),"\x3e"].join("")],null)},new $APP.z(function(){return hA},wC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),EC,"honey/sql.cljc",20,1,1251,1251,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,YD],null)),"For both :case and :case-expr.",$APP.r(hA)?hA.F:null])),function(a,b){var c=$APP.M(b,0,null),d=$APP.M(b,1,null);c=Z.g?Z.g(c):Z.call(null,c);b=$APP.A(c);c=$APP.D(b);b=$APP.F(b);a=Lx($APP.me([a,new $APP.S(null,1,5,$APP.U,[d],null)]));d=$APP.A(a);a=$APP.D(d);d=$APP.F(d);return $APP.V.h($APP.V.h(new $APP.S(null,1,5,$APP.U,[[$APP.t.g(c)," ",$APP.t.g(a)].join("")],null),b),d)},new $APP.z(function(){return Yz},
JC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),MC,"honey/sql.cljc",18,1,1204,1204,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Yz)?Yz.F:null])),function(a,b){a=$APP.M(b,0,null);b=$APP.M(b,1,null);a=Z.g?Z.g(a):Z.call(null,a);var c=$APP.A(a);a=$APP.D(c);c=$APP.F(c);return $APP.V.h(new $APP.S(null,1,5,$APP.U,[["INTERVAL ",$APP.t.g(a)," ",xx(b)].join("")],null),c)},aA,function(a,b){a=$APP.A(b);b=$APP.Ia(function(c,d){var e=$APP.M(c,0,null);c=$APP.M(c,1,null);var f=$APP.M(d,0,null),g=$APP.M(d,1,null);d=$APP.M(d,2,null);
f=Z.g?Z.g(f):Z.call(null,f);var k=$APP.A(f);f=$APP.D(k);k=$APP.F(k);g=null==g||$APP.Vc(g)?Qz(g,$APP.K([new $APP.q(null,1,[Kx,!0],null)])):new $APP.S(null,1,5,$APP.U,[wx(g)],null);var l=$APP.A(g);g=$APP.D(l);l=$APP.F(l);return new $APP.S(null,2,5,$APP.U,[$APP.Ed.h(e,[$APP.t.g(f)," OVER ",$APP.t.g(g),$APP.r(d)?[" AS ",wx(d)].join(""):null].join("")),$APP.V.h($APP.V.h(c,k),l)],null)},new $APP.S(null,2,5,$APP.U,[$APP.Oe,$APP.Oe],null),a);a=$APP.M(b,0,null);b=$APP.M(b,1,null);return $APP.V.h(new $APP.S(null,
1,5,$APP.U,[$APP.Yh(", ",a)],null),b)},function(a,b){a=$APP.M(b,0,null);return new $APP.S(null,1,5,$APP.U,[wx(a)],null)},new $APP.z(function(){return Yz},JC,$APP.kg([$APP.Jn,$APP.wn,$APP.mk,$APP.Ci,$APP.Sm,$APP.Vj,$APP.Di,$APP.On,$APP.Rm,$APP.X,$APP.xn],[!0,$APP.N(vy,new $APP.q(null,1,[$APP.X,"Primary API for HoneySQL 2.x.\n\n  This includes the `format` function -- the primary entry point -- as well\n  as several public formatters that are intended to help users extend the\n  supported syntax.\n\n  In addition, functions to extend HoneySQL are also provided here:\n  * `clause-order` -- returns the current clause priority ordering;\n        intended as aid when registering new clauses.\n  * `format-dsl` -- intended to format SQL statements; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-entity` -- intended to format SQL entities; returns a string\n        representing the SQL entity.\n  * `format-expr` -- intended to format SQL expressions; returns a vector\n        containing a SQL string followed by parameter values.\n  * `format-expr-list` -- intended to format a list of SQL expressions;\n        returns a pair comprising: a sequence of SQL expressions (to be\n        join with a delimiter) and a sequence of parameter values.\n  * `register-clause!` -- register a new statement/clause formatter.\n  * `register-fn!` -- register a new function call (or special syntax)\n        formatter.\n  * `register-op!` -- register a new operator formatter.\n  * `set-dialect!` -- set the default dialect to be used for formatting,\n        and optionally set a global `:quoted` option.\n  * `sql-kw` -- turns a Clojure keyword (or symbol) into SQL code (makes\n        it uppercase and replaces - with space). "],
null)),MC,"honey/sql.cljc",18,1,1204,1204,$APP.W(new $APP.S(null,2,5,$APP.U,[$APP.Fn,Iz],null)),null,$APP.r(Yz)?Yz.F:null])),function(a,b){a=$APP.M(b,0,null);b=Ex;Ex=!0;try{return Z.g?Z.g(a):Z.call(null,a)}finally{Ex=b}},function(a,b){a=$APP.M(b,0,null);if($APP.Vc(a))return a=Lx(a),b=$APP.A(a),a=$APP.D(b),b=$APP.F(b),$APP.V.h(new $APP.S(null,1,5,$APP.U,[["LATERAL (",$APP.t.g(a),")"].join("")],null),b);a=Z.g?Z.g(a):Z.call(null,a);b=$APP.A(a);a=$APP.D(b);b=$APP.F(b);return $APP.V.h(new $APP.S(null,
1,5,$APP.U,[["LATERAL ",$APP.t.g(a)].join("")],null),b)}]));var lE=Math.floor(1E3*Math.random()),aB=$APP.hl.g(null),TA=function TA(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return TA.l(0<c.length?new $APP.jc(c.slice(0),0,null):null)};TA.l=function(a){return $APP.ee($APP.zm,["[worker ",$APP.t.g(lE),"]"].join(""),a)};TA.H=0;TA.G=function(a){return this.l($APP.A(a))};
var mE=function mE(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return mE.l(0<c.length?new $APP.jc(c.slice(0),0,null):null)};mE.l=function(a){console.error($APP.D(a));return $APP.ee($APP.zm,["[worker ERR ",$APP.t.g(lE),"]"].join(""),a)};mE.H=0;mE.G=function(a){return this.l($APP.A(a))};TA.l($APP.K(["init!"]));self.addEventListener("message",function(a){TA.l($APP.K([["received: ",$APP.t.g(a.data)].join("")]));return bB($APP.dk(a.data))});TA.l($APP.K(["sqlite3 loading..."]));importScripts("sqlite3.js");
self.sqlite3InitModule({print:TA,printErr:mE}).then(function(a){TA.l($APP.K(["sqlite3 ready",a.version.libVersion]));console.log(a);try{if($APP.Ba(a.opfs))var b=mE.l($APP.K(["OPFS is not available"]));else{var c=$APP.r(a.opfs)?new a.oo1.OpfsDb("/mydb.sqlite3"):null;$APP.Be(aB,c);TA.l($APP.K(["init-db-file"]));console.log(c);b=UA(c)}return b}catch(d){return a=d,mE.l($APP.K([a.name,a.message]))}});
}).call(this);